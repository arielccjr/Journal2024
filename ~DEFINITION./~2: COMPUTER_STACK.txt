~FOR THE STACK:
~BODY:
        : Eat/Power       = Create/Heat/PowerSupply
		: Inhale/Cooler   = Exhale/Exhaust
		: Feel/Keyb/Mouse = Move/Animation/Events
		: Hear/Microphone = Speak/Speaker
		: See/Camera      = Show/Screen, GUI, CRTs>Scanning>Pixels, DesktopMetaphor, 3DProjection,
~HARDWARE:
    : Infrastructure: InternetDeepSeaCables, CopperWire/EthernetCable/RadioWaves/WiFi/Signals
    : Computer: Central/Graphical Processing Unit (C/GPU), Transistor>IntegratedCircuit>PrintedCircuitBoards>Semiconductor 
        : Clock
        : Temporary Memory Registers:
            : Instruction-Address Register >>> Address Input >>> Address = Data in RandomAccessMemory (RAM) >>> Instruction Register: FETCH PHASE
                : Multiplexer: MUX = (a AND NOTsel) OR (sel AND b)
                    : NOT (in=sel, out=NOTsel)
                    : AND (in=a, in=NOTsel, out=aANDNOTsel)
                    : AND (in=sel, in=b, out=selANDb)
                    : OR (in=aANDNOTsel, in=selANDb, out=out)
                : Matrix >>> Gate >>> AND-OR Latch: Memory Address
                    : AND (in=column, in=row, out=columnANDrow)
                        : AND (in=data, in=write-enable, out=set)
                        : NOT (in=data, out=NOTdata)
                        : AND (in=NOTdata, in=write-enable, out=reset)
                            : OR (in=set, in=outLOOP, out=setORoutLoop)
                            : NOT (in=reset, out=NOTreset)
                            : AND (in=setORoutLOOP, in=NOTreset, out=out)
                : Memory Register/Bit: Flip Flops: out[t] = in[t-1]
                    : OR-LOOP (in=a, in=b, out=1)
                    : AND-LOOP (in=a, in=b, out=0) 
            : Instruction Register decodes Data into OperationsCode (OPCODE): DECODE PHASE
            : Registers A, B, C... for loading values temporarily. 
        : Arithmetic Unit = Half>Full>Multi-bit Adder:
            : XOR (in=a, in=b, out=abSUM)
                : AND (in=a, in=b, out=aANDb);
                : NOT (in=aANDb, out=NOTaANDb);
                : OR (in=a, in=b, out=aORb);
                : AND (in=NOTaANDb, in=aORb, out=out);
            : AND (in=a, in=b, out=abCARRY)
                : >XOR (in=abSUM, in=c, out=abcSUM)
                : >AND (in=abSUM, in=c, out=abcCARRY)
                    ; >OR (in=abCARRY, in=abcBARRY, out=out)
        : Logic Unit: Mux/DMux >>> Xor >>> Or >>> And/Nand >>> Not
        : Flags of Bits: Overflow(>), Zero(=), Negative(<)...
	: In-Output Devices/Peripherals:
		: Eat/Power       = Create/Heat/PowerSupply
		: Inhale/Cooler   = Exhale/Exhaust
		: Feel/Keyb/Mouse = Move/Animation/Events
		: Hear/Microphone = Speak/Speaker
		: See/Camera      = Show/Screen, GUI, CRTs>Scanning>Pixels, DesktopMetaphor, 3DProjection,
~SOFTWARE: 
    : LAYERS OF THE OPEN SYSTEM INTERCONNECTION (OSI) MODEL: 
        : Physical Layer: Transistors convert digital signals (0s and 1s) into electrical, light, or radio waves
        : Data Link Layer: The frames are reassembled and validated for any transmission errors.
        : Network Layer: The packets are reassembled, and IP addresses are used to confirm the data arrived at the correct destination.
            : Internet Protocol (IP): Header = InternetServiceProvider(ISP)>Wide>LocalAreaNetwork>MAC Address
        : Transport Layer: Segments are reassembled, and any lost data is retransmitted.
            : Transmission Control Protocol (TCP): TCP Header = Software Port + Checksum
        : Application Layer: The data is handed off to the application that requested it, such as a web browser displaying a webpage.
            : Data Payload (UDP): Data
                : Domain Name System (DNS) + Web-Server Address: Universal Resource Locator (URL) + Hyperlinks
                : Web-Browser/Search-Engine: Hypertext Transfer Protocol (HTTP)
                    : Index: Frequency of Words
                    : Hypertext Markup Language (HTML) + CSS
~MEMORY:        
    : Files System:
        : Directory = Name, Type, Root>Sub, Hierarchical/Flat, Metadata: Length, 
            : Memory Size/Length: (4/8(byte)/16(word)/32/64/128)
    : File Types: Array, Libraries, Node/Tree, Graph/Web/Forest, 3D Matrix... 
        : Wave/Audio: Amplitude, Spectogram... 
        : Bitmap: GraphicsGenerator>ScreenBuffer(ImageWidthxHeight)
        : Character/Text/List/String = ASCII>UNICODE
        : Number/Integer/Float= 
            : Scientific Notation; Negative Bit= 2^N-x
            : Null
    : Knowledge(Known)/Facts:
        :
    : Memory Bit: BinaryStates = 0, 1 (Base-2 Notation)
        : Memory Address:
            : Pointer: Next Address Reference
            : Index
        : Instruction
~INSTRUCTION: FLOW/MOTION-STATE: HABIT-LOOP= STIMULUS >>> REACTION(INSTANT-GRATIFICATION), RESULT(s, a): returns state after action a taken in state s
    : IN:SEE/HEAR/FEEL/SMELL/TASTE(STIMULUS) - OUT:MIRROR/BE(SEEN/HEARD/FELT/SMELLED/TASTED)
        : Console Input/Output: Reads from and writes to the console. To interact with the user.
        : Execute ControlFlow:
            : Triggers: Automatically executes actions in response to table events. To enforce rules and maintain data integrity.
                : If/While/For... function(input1, 2)
            : Conditionals: Enables decision-making in code. To perform actions based on conditions.
                : If/ElseIf/Else: Executes code based on logical conditions. To handle multiple outcomes.
                : Switch: Simplifies multi-condition branching. To streamline complex conditional logic.
                : Exception Handling: Manages runtime errors. To handle errors gracefully and ensure program stability.
            : Loops: Repeats code execution based on conditions. To perform repetitive tasks.
                : While: Repeats while a condition is true. To handle indefinite iteration.
                : Do-While: Executes at least once before checking conditions. To ensure at least one iteration.
                : For: Iterates a specific number of times. To handle definite iteration.
                : Continue Statement: Skips to the next iteration. To bypass unnecessary code in specific cases.
                : Break Statement: Exits a loop or switch statement early. To terminate iterations based on conditions.	
            : Return Statement: Exits a function and optionally returns a value. To end execution and provide a result.
                : Then/Else/Next... 
            : Brute Force, Selection, Merge, Dijkstra... 
    
    : DATABASE ENGINE: The core set of programs in a DBMS that handles all database operations.
        : DATA DEFINITION LANGUAGE (CREATE, ALTER, DROP commands): Sets up the database structure for efficient storage.
        : SQL Queries (SELECT, WHERE, JOIN, AGGREGATE functions): Extract insights and support decision-making.
        : DATA MANIPULATION LANGUAGE (INSERT, UPDATE, DELETE statements): Keep datacase data updated and accurate.
        : STORED PROCEDURES (CREATE, PROCEDURE, parameters, transactions, and error handling): Improve performance and handle business logic efficiently.
        : TRIGGERS (CREATE TIGGER for INSERT, UPDATE, DELETE): Enforce rules and log/audit changes automatically.
    
    : NATURAL LANGUAGE PROCESSING:
        : tokenization = the task of splitting a sequence of characters into pieces (tokens)
        : text classification =
        : Naive-Bayes classifier = 
        : additive smoothing = adding a value a to each value in our distribution to smooth the data  
            : Laplace smoothing = adding 1 to each value in ou r distribution: pretending we've seen each value one more time than we actually have
        : Word Representation
        : Attention = letting us decide which values are important to pay attention to when generating, in this case, the next word in our sequence.
        : Machine Translation 
        
        : Transformers Architecture
            : Encoder: input word + positional encoding >>> (multi-head self attention >>> neural network) * Number >>> encoded representation
            : Decoder: previous output word + positional encoding >>> (multi-head self attention >>> (encoded representations) attention >>> neural network) * Number >>> encoded representation
    : NEURAL NETWORKS:
        : artificial neural network = mathematical model for learning inspired by biological neural networks
            : Model mathematical function from inputs to outputs based on the structure and parameteres of the network.
            : Allows for learning the network's parameters based on data.
            : Functions:
                : step function: g(x) = 1 if x > 0, else 0
                : logic sigmoid
                : rectified linear unit (relu)
            : h(x1, x2) = g(w0 + w1x1 + w2x2)
            : h(x1, x2, xn-1, xn) = g(n sigma i=1 xiwi + w0)
        : supervised neural network: 
            : gradient descent = algorithm for minimizing loss when training neural network
                : Start with a random choice of weights.
                : Repeat: 
                    : Calculate the gradient based on ALL DATA POINTS: direction that will lead to decreasing loss.
                    : Update weights according to the gradient.
            : Stochastic gradient descent
                : Start with a random choice of weights.
                : Repeat: 
                    : Calculate the gradient based on ONE DATA POINTS: direction that will lead to decreasing loss.
                    : Update weights according to the gradient.
            : Mini-Batch gradient descent
                : Start with a random choice of weights.
                : Repeat: 
                    : Calculate the gradient based on ONE SMALL BATCH: direction that will lead to decreasing loss.
                    : Update weights according to the gradient.
        : multilayer neural network = artificial neural network with an input layer, an output layer, and at least one hidden layer 
        : backpropagation = algorithm for training neural netowrks with hidden layers
            : Start with a random choice of weights.
            : Repeat:
                : Calculate error for output layer.
                : For each layer, starting with output layer, and moving inwards towards earliest hidden layer:
                    : Propagate error back one layer.
                    : Update weights.
        : deep neural networks = neural network with multiple hidden layers
        : dropout = temporarily removing units - selected at random - from a neural network to prevent over-reliance on certain units
        : computer vision = computational methods for analyzing and understanding digital images
        : image convolution = applying a kernel/filter that adds each pixel value of an image to its neighbors, weighted according to a kernel matrix
        : pooling = reducing the size of an input by sampling from regions in the input
            : max-pooling = pooling by choosing the maximum value in each region
        : convolutional neural network = neural networks that use convolution, usually for analyzing images
            : Apply convolution
            : Apply pooling
            : Apply Flattening
            : Apply Deep Neural Networks
        : feed-forward neural network = neural network that has connections only in one direction
            : input >>> network >>> output
        : recurrent neural network: input >>> network (loop) >>> output
            : Relationships:
                : one-to-many 
                : many-to-one
                : many-to-many
    : LEARNING:
        : supervised learning = given a data set of input-output pairs, learn a function to map inputs to outputs
            : classification = supervised learning task of learning a function mapping an input point to a discrete category
                : nearest-neighbor classification = algorithm that, given an input, chooses the class of the nearest data point to that input
                : k-nearest-neighbor classification = algorithm that, given an input, chooses the most common class out of the k nearest data points to that input
            : hypothesis hw(x) = 1 if w * x > 0; 0 otherwise
            : perceptron learning rule = given data point (x, y), update each weight according to: 
                : wi = wi + a(y - hw(x)) * xi
                : wi = wi + a(actual value - estimate) * xi
                : Only capable of learning linearly separable decision boundary.
            : Support Vector Machine
                : boundary that maximizes the distance between any of the data points 
            : regression = supervised learning task of learning a function mapping an input point to a continuous value
            : regularization = penalizing hypotheses that are more complex to favor simpler, more general hypotheses
            : holdout cross-validation = splitting data into a training set and a test set, such that learning happens on the training set and is evaluated on the test set
            : k-fold cross-validation = splitting data into k sets, and experimenting k times, using each set as a test set once, and using remaining data as training set
        : reinforcement learning = given a set of rewards or punishments, learn what actions to take in the future
            : Q-learning = method for learning a function Q(s,a), estimate of the value of performing action a in state s
                : Start with Q(s,a)=0 for all s,a
                : When we take an action and receive a reward:
                    : Estimate the value of Q(s,a) based on current reward and expected future rewards
                    : Update Q(s,a) to take into account old estimate as well as our new estimate
            : Greedy Decision-Making
                : When in state s, choose action a with the highest Q(s,a)
            : Explore vs Exploit 
                : Epsilon-Greedy:
                    : Set epsilon equal to how often we want to move randomly.
                    : With probability 1 - epsilon, choose estimated best move.
                    : With probability epsilon, choose random move.
            : function approximation = approximating Q(s,a) often by a function combining various features, rather than storing one value for every state-action pair
        : unsupervised learning = given input data without any additional feedback, learn patterns
            : clustering = organizing a set of objects into groups in such a way that similar objects tend to be in the same group
                : k-means clustering = algorithm for clustering data based on repeatedly assigning points to clusters and updating those clusters' centers
    : OPTIMIZATION:
        : Local Search = algorithms that maintain a single node and searches by moving to a neighboring node
            : Hill Climbing
                : function HILL-CLIMB(problem):
                    : current = initial state of problem
                    : repeat:
                        neighbor = highest valued neighbor of current
                        if neighbor not better than current:
                            return current
                        current = neighbor
                : steepest-ascene = choose the highest-valued neighbor
                : stochastic = choose randomly from higher-valued neighbors
                : first-choice = choose the first higher-valued neighbor
                : random-restart = conduct hill climbing multiple times
                : local beam search = chooses the k highest-valued neighbors
            : Simulated Annealing =
                function SIMULATED-ANNEALING(problem, max):
                    current = initiate state of problem 
                    for t = 1 to max:
                        T = TEMPERATURE(t)
                        neighbor = random neighbor of current 
                        deltaE = how much better neigh is than current
                        if deltaE > 0:
                            current = neighbor
                        with probability e^deltaE/T set current = neighbor
                    return current
            : Linear Programming:
                : Simplex
                : Interior-Point
            : arc consistency = when all the values in a variable's domain satisfy the variable's binary constraints
                : function REVISE(csp, X, Y):
                    revised = false
                    for x in X.domain:
                        if no y in Y.domain satisfies constrain for (x, Y):
                            delete x from X.domain
                            revised = true
                        return revised
                : function AC-3(csp)
                    queue = all arcs in csp
                    while queue non-empty:
                        (X, Y) = DEQUEUE(queue)
                        if REVISE(csp, X, Y):
                            if size of X.domain == 0:
                                return false
                            for each Z in X.neighbors - {Y}:
                                ENQUEUE(queue, (Z, X))
                        return true 
            : Backtracking Search:
                : function BACKTRACKING(assignment, csp):
                    if assignment complete: return assignment
                    var = SELECT-UNASSIGNED-VAR(assignment, csp)
                    for value in DOMAIN-VALUES(var, assignment, csp):
                        if value consistent with assignment:
                            add {var = value} to assignment
                            result = BACKTRACK(assignment, csp)
                            if result not= failure: return result
                        remove {var = value} from assignment
                    return failure
            : maintaining arc consistency = algorithm for enforcing arc-consistency every time we make a new assignment 
                : function BACKTRACKING(assignment, csp):
                    if assignment complete: return assignment
                    var = SELECT-UNASSIGNED-VAR(assignment, csp)
                    for value in DOMAIN-VALUES(var, assignment, csp):
                        if value consistent with assignment:
                            add {var = value} to assignment
                            inferences = INFERENCES(assignment, csp)
                            if inferences not= failure: add inferences to assignment
                            result = BACKTRACK(assignment, csp)
                            if result not= failure: return result
                        remove {var = value} and inferences from assignment
                    return failure
    : PROBABILITY: 
        : Bayes' Rule: P(b | a) = P(a | b) P(b) / P(a)
        : Probability Rules:
            : Negation
            : Inclusion-Exclusion
            : Marginalization
            : Conditioning
        : Inference by Enumeration
        : Approximate Inference:
        : Sampling
            : Rejection Sampling
            : Likelihood Weighting
        : hidden Markov Model: Task:
            : Filtering = given objservations from start until now, calculate distribution for current state
            : prediction = given observations from start until now, calculate distribution for a future state
            : smoothing = given observations from start until now, calculate distribution for past state
            : most likely explanation = given observatinos from start until now, calculate most likely sequence of states
    
    : KNOWLEDGE:
        : Logical Connectives: 
            : not ¬, 
            : and ∧, 
            : or ∨,
            : implication →
            : biconditional ↔
        : Entailment Algorithm: Does KB ⊨ α ?
        : Model Checking: (logic.py)
            : To determine if KB ⊨ α:
                : Enumerate all possible models.
                : If in every model where KB is true, α is true, then KB entals α.
                : Otherwise, KB does not entail α.
        : Knowledge Engineering:
        : Inference Rules:
            : Modus Ponens: α → β
            : And Elimination: α ⊨ β
            : Double Negation Elimination:
            : Implication Elimination
            : Biconditional Elimination
            : De Morgan's Law
            : Distributive Property/Law
            : Unit Resolution
        : Conversion to conjunctive normal form (CNF)
            : Eliminate biconditionals
            : Eliminate implications
            : Move not inwards using De Morgan's laws
            : Use distributive law to distribute or wherever possible
        : Inference by Resolution
            : To determine if KB ⊨ α:
                : Convert (KB and not alpha) to Conjunctive Normal Form.
                : Keep checking to see if we can use resolution to produce a new clause.
                    : If ever we produce the empty clause (equivalent to false), we have a contradiction, and KB ⊨ α.
                    : Otherwise, if we cannot add new clauses, no entailment.
        : First-Order Logic
            : Universal Quantificationa
            : Existential Quantification
    
    : SEARCH/Queries: Retrieves specific data from the database. To access and analyze stored information.
        : Sub-Query: Uses the result of one query within another query. To filter or derive conditions dynamically.
        : Uninformed Search: 
            : Depth-First (Stack)
                : Start with a frontier that contains the intitial state.
                : Start with an empty explored set.
                : Repeat:
                    : If the frontier is empty, then no solution.
                    : Remove a node from the frontier.
                    : If node contains goal state, return the solution.
                    : Add the node to the explored set.
                    : Expand node, add resulting nodes to the frontier, if they are NOT already in the frontier or the explored set.
            : Breadth-First (Queue)
        : Informed Search: with Heuristic Function
            : Greedy Best-First
            : A*: g(n) + h(n)
                : g(n) = cost to reach node
                : h(n) = estimated cost to goal 
                : optimal if:
                    : h(n) is admissible (never overestimates the true cost)
                    : and h(n) is consistent (for every node n and successor n' with step cost c, h(n) < h(n') + c) 
        : Adversarial Search: with Adversary
            : Minimax: Win-Lose Goal-State
                : Set Agents:
                    : MAX aims to maximize score
                    : MIN aim to minimize score
                : Set Outcomes: 
                    : -1 = Lose
                    : 0 = Tie
                    : +1 = Win
                : Given a state s:
                    : MAX picks action a in ACTIONS(s) that produces highest value of MIN-VALUE(RESULTS(s, a))
                    : MIN picks action a in ACTION(s) that produces smallest value of MAX-VALUE(RESULTS(s, a))
                : Pseudocode:
                    function MAX-VALUE(state):
                        if TERMINAL(state):
                            return UTILITY(state)
                        v = -infinity
                        for action in ACTIONS(state):
                            v = MAX(v, MIN-VALUE(RESULT(state, action)))
                        return v
                    
                    function MIN-VALUE(state):
                        if TERMINAL(state):
                            return UTILITY(state)
                        v = infinity
                        for action in ACTIONS(state):
                            v = MIN(v, MAX-VALUE(RESULT(state, action)))
                        return v
            : Alpha-Beta Pruning
            : Depth-Limited Minimax: with Evaluation function
        
        : Initialization/Declarations: Allocates memory space for storing data. To store data that can be used and manipulated in a program.
            : Import/Include: Brings in external libraries or namespaces. To use classes and methods from other libraries.
            : Assign: Initializes or updates the value of a variable. To give variables usable values.
            : Compare: Less Than, Greater Than, Equal

   
    ~FREE-WILL: STOP-&-CORRECT = NOT-IN:BLINK/DEAFEN/FLEE/MASK/FAST() - NOT-OUT:HIDE/MUTE/PAUSE/BLOW/SPIT()
        ~READ/LOAD(FRONTIER), MEMORY/CATEGORIES/EXPLORED-SET; TERMINAL(s): checks if state s is a terminal state; "Is Frontier Goal?"
           : Categorize:
                : SYNTAX: SENTENCE, STORYLINE= ARISTOTLE'S RHETORIC
                : WORD: PARSE/ETYMOLOGY
                    : Roots: Fact/Known
                        : WHEN: SCHEDULE= Start*Finish... ClockCycle/Hertz/Second/Minute/Hour/Day/Month/Season/Year...: CHRONOLOGY
                        : WHERE: HOME= Length*Width*Height... Checkpoint/Position/Address/Continent/Sea/Climate...: ASTRONOMY (PTOLEMY), GEOGRAPHY
                        : WHO: FAMILIAR= Mother*Father... Blood/Tribe/Ethnicity/Race/Specie/Genus/Status...: Personality Types / Characters (Theophrastus)
                        : WHAT: KNOWN= Contract & Copy Writing, Financial Statement...
                    : Fixes: Position-Lodial
                : SYMBOLS: Flags, International Beaureau of Weights and Measures in France
                    : Letters/Spells, 
                    : Metals, Conductors,
                    : Light: GEOMETRY (EUCLID)
                    : Sound: MUSIC (BOETHIUS)
                    : Motion: PHYSICS (ARISTOTLE)
                    : Energy: path cost function: number of steps in proof
                        : Positive (+1): +1=FRUIT/HERO/WAY/CHANCE FOR-BY SEEDWORD/FATHERGOD/KINGDOMHEAVEN/DEATHEND
                        : Negative (-1): -1=SPOIL/SACRIFICE/TRAP/WAIT FOR-BY SOILVOID/MOTHERBEAST/WILDWORLD/BIRTHSTART
                        : Neutral (0): 0=EXPERIENCE/CHILD/CONTACT/LIFE: UTILITY(s): final numerical value for terminal state s
                            : ~AGENT/PLAYER/CORPORATION: BODY/I/HERE/NOW: knowledge-based agent(s) that reason by operating on knowledge
       
        ~WRITE/ARRANGE()-ERASE-FORGET(BABBLE/WRONG)/CRUD, CORRECTNESS/REASON:
            : ARISTOTLE'S NICHOMACHEAN ETHICS
            : POSTAL MECHANICS + MARITIME LAW + ROBERT'S RULE OF ORDER
            : NOW-SPACE 
            : CORRECT-PARSE-SYNTAX-GRAMMAR: POSITION-LODIAL-FACT
                : FOR THE KNOWLEDGE OF THE FACT IS WITH THE PERFORMANCE BY THE AUTHORITY.
            : List: Queue/Stack, 
            : LOGIC-ARITHMETIC = -1, 0, +1
                : Arithmetic: XOR+ANDCarry/Half, Full, Multi-bit Adder
                : Logic: NOT, AND, OR
 
~INFORMATION SYSTEMS:
    What: Core components that make up an information system (IS), including data, hardware, and software.
    Why:
        To enable efficient data input, processing, and output.
        To support mission-critical operations vital to businesses.
        To set organizational direction and evaluate progress.
        To provide direction, support, and performance feedback.
        To ensure smooth day-to-day functioning.
        To execute specific tasks as part of business workflows.
    How:
        Define the system’s purpose and scope.
        Identify and integrate hardware components (physical systems).
        Develop and implement software (programs controlling the hardware).
        Collect and process input data to achieve specific results.
            Use data from enterprise systems.
                Monitor trends and forecast growth.
                Allocate resources effectively.
            Use MIS and DSS for insights.
                Plan resources and delegate tasks.
                Perform analysis and generate reports.
            Oversee staff and operations.
                Provide immediate feedback.
                Use TPS for monitoring workflows.
            Enter data into TPS.
                Process tasks (e.g., reservations, orders).
                Rely on automated systems for efficiency.
        
    ~BUSINESS USE OF INFORMATION TECHNOLOGY: How IT is used to support different business operations and decision-making processes.
        1. Enterprise Computing Systems: Systems that support company-wide operations and strategic decision-making (e.g., ERP systems).
            Why: To enhance productivity, reduce costs, and support decision-making.
            How:
                Implement structured rules for predictable tasks.
                Use ERP to consolidate operations into a single system.
                Ensure scalability for future growth.
        2. Transaction Processing Systems (TPS): Applications that handle daily operations like orders, reservations, and payroll.
            Why: To automate repetitive tasks, improve accuracy, and maintain data integrity.
            How:
                Collect input data for transactions.
                Process data in real-time or batch mode.
                Produce outputs for operations (e.g., receipts, records).
        3. Business Support Systems (MIS): Systems for generating management reports to aid decision-making.
            Why: To provide insights and summaries of operations.
            How:
                Collect data from TPS or other sources.
                Generate detailed, summary, or exception reports.
                Use reports for analysis and decision-making.
        4. Decision Support Systems (DSS): Tools for performing “what-if” analyses and making decisions.
            Why: To evaluate alternatives and improve decision-making.
            How:
                Analyze data using simulations.
                Present insights with interactive dashboards.
                Test multiple scenarios to identify optimal solutions.
        5. Knowledge Management Systems (KMS): Advanced systems using expert knowledge to simulate reasoning and provide solutions.
            Why: To leverage expertise, manage knowledge, and ensure consistent decisions.
            How:
                Build a knowledge base with encoded rules.
                Use fuzzy logic to manage imprecise relationships.
                Apply inference rules for decision-making.
    
    ~FUNCTIONAL REQUIREMENTS: define what the system is supposed to do. They describe specific behaviors, actions, or tasks the system must perform, focusing on inputs, processing, and outputs.
        Why (For What):
            To ensure the system meets its intended purpose and fulfills the user’s needs.
            To define what features and behaviors the system must include for proper operation.
        How (By What Logical Steps):
            Identify the core objectives and purpose of the system.
            Gather input from stakeholders and users regarding what tasks the system must perform.
            Document specific system actions and interactions, such as:
                Business rules.
                Authentication and authorization processes.
                Transaction processing (corrections, adjustments, cancellations).
                Audit tracking and external interfaces.
            Test functionality to verify the system performs as defined.
        Examples:
            A banking system must allow users to transfer funds (Transaction Processing).
            A website requires users to log in with a username and password (Authentication).
            A system must record and store data changes for future reference (Audit Tracking).
    ~NON-FUNCTIONAL REQUIREMENTS: Non-functional requirements specify how the system performs its tasks. They focus on qualities such as performance, reliability, usability, and scalability rather than specific behaviors.
        Why (For What):
            To ensure the system operates efficiently, securely, and reliably under various conditions.
            To improve user experience and ensure compliance with regulatory and operational standards.
        How (By What Logical Steps):
            Define quality standards and expectations for the system.
            Identify specific non-functional requirements, such as:
                Performance (response times, system throughput).
                Scalability (ability to handle growth in users or data).
                Security (data protection, access control).
                Usability (ease of use for end users).
            Develop and implement system architecture to meet these requirements.
            Test the system to verify non-functional attributes under various scenarios (e.g., load testing, recovery testing).
        Examples:
            The system should handle 10,000 simultaneous users (Scalability).
            Data recovery must occur within 2 hours after a system crash (Recoverability).
            The system should respond to user requests within 2 seconds (Performance).
    
    ~COMPARISON: Functional vs. Non-Functional Requirements
        Aspect	    Functional Requirements	                                Non-Functional Requirements
        What it defines	What the system does.	                            How the system performs its tasks.
        Focus	    Features and user requirements.                         System quality and operational attributes.
        Examples	Transaction processing, authentication, audit tracking. Performance, scalability, reliability, usability.
        Impact	    System won’t function if unmet.	                        System still functions, but quality may be compromised.
        Testing	    Validate features and tasks.	                        Validate performance and reliability under different conditions.
        Conclusion:
        Why Both Are Important:
            Functional Requirements ensure the system performs its intended tasks.
            Non-Functional Requirements ensure the system performs efficiently, securely, and reliably, improving user satisfaction and long-term operational success.
        How to Address Both:
            Document functional requirements first to define system behavior.
            Develop non-functional requirements to establish quality standards.
            Use iterative testing to ensure compliance with both types of requirements.
    
    ~BUSINESS RULES: A business rule is a statement that defines or influences how a business operates. It governs decisions, processes, and behavior within an organization. Business rules:
        Why (For What):
            To maintain consistent operations and decision-making.
            To enforce organizational policies and legal requirements.
            To automate processes and reduce reliance on human judgment.
            To create new knowledge by systematically applying rules to existing data.
        How (By What Logical Steps):
            Define the behavior or decision the rule governs.
            Observe and document implicit and explicit rules (some may not be written).
            Integrate these rules into business processes or systems.
            Ensure the rule is clear, justified, and enforceable.
            Test the rule in real-world scenarios to ensure it works as intended.
        How Does That Work?
            Example: Hotel Reservation Rule
            What: A customer cannot check in without a reservation.
            Who: Hotel clerks enforce the rule, and the hotel’s booking system supports it.
            Where: At the hotel’s front desk during check-in.
            When: When a customer arrives to check in without prior reservation.
            Why (For What): To ensure efficient room allocation and avoid overbooking.
            How:
                The clerk asks if the customer has a reservation.
                If not, the clerk creates a reservation in the system.
                The customer is then checked in, satisfying the business rule.
        
        ~PROPERTIES OF A GOOD BUSINESS RULE: A good business rule should meet specific criteria to ensure clarity, enforceability, and alignment with business objectives.
            Why (For What): To ensure rules are actionable, clear, and relevant to organizational goals.
            How (By What Logical Steps):
                Atomic: Ensure the rule focuses on a single concept or action.
                    Example: "We only ship complete orders."
                Declarative: Specify when and how the rule applies.
                    Example: "Before a work order can be completed, a customer’s information must be collected."
                Precise: Avoid ambiguity or multiple interpretations.
                    Example: "Any customer that owes more than $5,000 cannot place new orders."
                Justified: Confirm the rule supports business objectives.
                Authorized: Ensure the rule is created by someone with decision-making authority.
        
        ~BUSINESS RULE EXAMPLES: Practical examples that demonstrate how business rules guide actions and processes.
            Examples:
                Everyone under the age of 25 must have their ID checked (compliance rule).
                Orders are only shipped when complete (operational rule).
                Customers with debts over $5,000 cannot place new orders (financial rule).
                Vehicles must be visually inspected for damage before release (safety rule).
            Why (For What): To ensure compliance, efficiency, safety, and financial prudence.
            How:
                Define the rule clearly.
                Train staff and configure systems to enforce the rule.
                Monitor adherence and adjust as needed.

    ~SYSTEM DESIGN: DEVELOPMENT LIFECYCLE:
        : Requirement Gathering: CLIENT INTERVIEWING is a technique used during the requirements-gathering phase 
            The objective is to collect accurate, complete, and specific information about the client’s needs, their business processes, and how a system can improve those processes. This includes identifying workflows, data storage practices, user needs, and system functionality.
            HOW (BY WHAT LOGICAL STEPS):
                Prepare for the Interview:
                    Research the business: Understand their workflows, current system, and competitive landscape.
                    Identify stakeholders to interview (users, supervisors, decision-makers).
                    Develop a list of targeted questions tailored to the client’s operations.
                Conduct the Interview:
                    Start with open-ended questions: Get a general understanding of workflows and goals.
                    Dive deeper with specific queries:
                        How is data stored and accessed?
                        What physical and digital documents exist?
                        What triggers activities (e.g., time, requests, documents)?
                        Who performs the work? Are they users or information receivers?
                    Address business details: Operating hours, equipment, and competitors.
                    Use a structured approach like role-play, use cases, and scenarios when clients struggle with articulating needs.
                Overcome Communication Barriers:
                    For limited client perspectives:
                        Analyze their role, responsibilities, and system usage.
                        Explain the broader context of the system to clarify its impact.
                    For resistance to the project:
                        Conduct group interviews with supervisors present.
                        Record sessions for accuracy.
                        Ask direct and detailed questions, avoiding reliance on volunteered information.
                    For technical document misunderstandings:
                        Simplify the language and explain diagrams like Data Flow Diagrams (DFDs).
                        Walk through processes step-by-step to connect system actions to real-world operations.
                    For high-level, vague feedback:
                        Ask detailed questions about specific functionality or design elements.
                        Provide examples to guide input (e.g., "Are the filter options sufficient for your search?").
                Validate Findings:
                    Confirm the interview results through prototypes, role-play, or group reviews.
                    Ensure all activities, data flows, and user needs are verified.
                    Check if additional details are needed.
                Iterate and Refine:
                    Revisit unclear or incomplete requirements.
                    Use feedback from labs and prototypes to refine system understanding.
        : Planning + Design: Survey-Prove Investors
        : Prototyping (Testing) Development: FAIL FAST!
        : Deployment: Proven Product
        : Maintenance/Warranty
    : Source Control
        : Quality Assurance
        ; Roll Back
    : Repository:
        : Check in vs out
        : Committing

    : Class Definitions: Encapsulates data and behavior in a blueprint for objects. To create reusable structures for organizing data and logic.
        : Functions: Encapsulates reusable blocks of code. To simplify and modularize tasks.
    : Transactions: Groups operations as a single unit of work. To ensure data consistency and integrity.
        : Views: Creates virtual tables based on SQL queries. To simplify complex queries and enhance security.
        : Stored Procedures: Encapsulates SQL statements for reuse. To standardize and simplify repetitive tasks.
    : Database Creation: Creates a new database. To systematically organize and store application data.
        : Table Creation: Defines a structured format for storing data in rows and columns. To organize data with specific attributes.

    ~SYSTEM DEVELOPMENT LIFE CYCLE (SDLC): A structured process used for planning, creating, testing, and deploying an information system. 
        Why (For What): 
            To create systems that align with business goals.
            To deliver projects on time, within budget, and meeting requirements.
        How (By What Logical Steps):
            System Planning:
                Identify and prioritize system needs.
                Define the scope and boundaries of the problem.
            System Analysis:
                Build a logical model.
                Analyze current problems and their root causes.
                Define and document business requirements.
            System Design:
                Design solutions (physical models, user interfaces, controls, and security).
                Produce a technical design document.
            System Implementation:
                Develop and deploy the system.
                Train users and create documentation.
                Plan conversion strategies (e.g., parallel, pilot, phased, or direct cutover).
            System Operation and Support:
                Monitor and maintain the system.
                Refine the system design and address issues.
                Ensure continued functionality throughout its useful life.
    
    ~SYSTEM DEVELOPMENT TOOLS/TECHNIQUES: Graphical representations of systems to visualize processes, data, and interactions.
        Why: To ensure clarity in understanding and communication.
        How: Create models like:
            Data Flow Diagrams (DFDs)
            Entity-Relationship Diagrams (ERDs)
            Unified Modeling Language (UML) diagrams.
    
    Prototyping: Building early, functional models of the system for testing and feedback.
        Why: To test ideas, refine requirements, and reduce risks.
        How:
            Develop prototypes based on requirements.
            Test feasibility and gather feedback.
            Iterate to improve before production.
    
    CASE Tools: Software tools for automating and assisting in system development.
        Why: To improve productivity and consistency in system development.
        How: Use CASE tools to:
            Generate designs automatically.
            Standardize methodologies.
            Enhance collaboration and documentation.

    Five Steps for Creating a Business Rule Collection: A structured approach to defining and managing a set of business rules.
        Why (For What): To systematically document and organize rules for clarity, relevance, and enforceability.
        How (By What Logical Steps):
            Collect business ramblings: Gather informal or implicit rules by observing operations and interviewing stakeholders.
            Translate these ramblings into business rules: Reword them into clear, structured statements.
                Example: "Orders must be shipped complete."
            Determine which rules are relevant to project objectives: Filter out irrelevant or outdated rules.
            Determine data-rule dependencies: Identify which data elements the rules depend on (e.g., customer age, reservation status).
            Determine inter-rule relationships: Map how rules interact or overlap to avoid conflicts.

~RISK ANALYSIS: Risk management is an integral part of project planning to prevent small issues from escalating into emergencies.
    What: Risk is composed of five key elements:
        Event: What could happen?
        Probability: How likely is the event to happen?
        Impact: How bad will it be if it happens?
        Mitigation: How can the probability be reduced?
        Contingency: How can the impact be reduced if it does happen?
     Why (For What):
        Risk refers to the potential positive or negative effects of an event or series of events on a project. 
        It encompasses uncertainty and its impact on project outcomes.
        To anticipate potential problems and avoid or minimize their effects.
        To take advantage of positive risks (opportunities) when they occur.
        To ensure smooth project execution.
        To avoid budget overruns, missed deadlines, or project failure.
        To build proactive strategies for unforeseen challenges.
        To create structured strategies for managing risks.
        To minimize the impact of negative events and maximize the potential of positive ones.
     How (By What Logical Steps):
        Define risks that could affect the project.
        Categorize risks as opportunities or threats.
        Assess their likelihood and potential impact.
        Develop mitigation and contingency strategies.
        Monitor risks throughout the project lifecycle.
        Include risk analysis as part of the project planning process.
        Continuously update the risk register as new risks are identified.
        Regularly evaluate risks to keep the project on track.
            Identify potential risks (events) in the project.
            Assign a probability (High, Medium, Low) to each event.
            Assess the impact of each event on the project.
            Develop mitigation strategies to lower the likelihood of occurrence.
            Develop contingency plans to reduce the impact if the event occurs.
    
    Creating a Risk List: A risk list is a prioritized collection of potential project risks, detailing their probability, impact, and mitigation/contingency plans.
        Why (For What):
            To organize and prioritize risks for proactive management.
            To provide clarity on which risks to address first.
        How:
            Describe the risk event briefly (1–2 sentences).
            Assign a probability (High, Medium, Low) to each risk.
            Develop mitigation strategies to reduce the likelihood of high/medium probability risks.
            Assess the impact (High, Medium, Low) of each risk.
            Develop contingency plans to address the impact if the risk materializes.
    Assessing Probability and Impact
        What:
            Probability: The likelihood of a risk occurring.
            Impact: The severity of the risk's effect on the project.
        Why (For What):
            To determine which risks to prioritize and address.
            To allocate resources effectively for risk management.
        How:
            Use a High, Medium, Low scale to categorize probability and impact.
            Address high-probability and high-impact risks first.
            Continuously re-evaluate risks as the project progresses.

    : Example of a Risk Event
        Why (For What): To avoid delays and ensure the project stays on schedule.
        How:
            Identify the risk event (parts delay).
            Assign Medium probability and High impact.
            Mitigate by ordering parts early in the project.
            Create a contingency plan to use existing parts temporarily.
    : Structured Analysis: A traditional methodology for breaking down system functions into detailed processes.
        Why: To ensure thorough understanding and structured documentation.
        How: Use tools like DFDs and process models to detail workflows.
    : Object-Oriented Analysis: A methodology that focuses on defining systems in terms of objects and their interactions.
        Why: To simplify design and enhance flexibility.
        How: Define objects, their properties, behaviors, and relationships.
    : Joint Application Development (JAD): Collaborative workshops for stakeholders to define requirements and design solutions.
        Why: To ensure alignment between business needs and technical solutions.
        How: Conduct structured sessions with stakeholders to gather input and refine requirements.
    : System Modeling: Modeling involves creating structured representations of a system to understand, analyze, and solve problems effectively.
        Why (For What):
            To provide structure to problem-solving.
            To explore multiple solutions efficiently.
            To abstract and simplify complex systems.
            To reduce development time and costs.
            To minimize risks and errors.
        How (By What Logical Steps):
            Identify the problem or system to be modeled.
            Define the goals of modeling (e.g., risk reduction, clarity).
            Create and test models using diagrams, simulations, or prototypes.
            Refine models based on feedback and iterations.

    : Feasibility: refers to assessing whether a proposed project is practical, achievable, and worthwhile to pursue. A feasibility study evaluates the potential success of a project across multiple dimensions.
        Why (For What):
            To determine if a project is worth pursuing in terms of cost, resources, and time.
            To identify risks, constraints, and benefits of the proposed project.
        How (By What Logical Steps):
            Define the project scope and objectives.
            Identify and evaluate feasibility criteria (operational, technical, economic, schedule).
            Collect data through interviews, surveys, and research.
            Analyze the data and prepare a feasibility report.
            Make a recommendation based on the findings.

    : Feasibility Study: A feasibility study is an ongoing process of tests to evaluate if a project is desirable, practical, and achievable. It ensures a project meets the following criteria:
            Operational feasibility: Operational feasibility evaluates whether the proposed system will be used effectively once implemented.
                Why (For What):
                    To ensure user adoption and effective use of the system.
                    To identify and mitigate risks such as workforce resistance or legal/ethical concerns.
                How:
                    Evaluate if management supports the project.
                    Assess workforce impacts (e.g., training, reductions).
                    Determine user involvement in planning and implementation.
                    Identify potential customer effects and risks to company image.
                    Check for conflicts with other organizational priorities.
            Technical feasibility: Technical feasibility examines the availability and adequacy of technical resources (hardware, software, expertise) to support the proposed system.
                Why (For What):
                    To determine if the organization has the necessary resources and expertise to implement the system.
                    To ensure the system can handle future needs and growth.
                How:
                    Assess the availability of required hardware and software.
                    Determine if the company has the technical expertise for development and maintenance.
                    Evaluate platform capacity for scalability and reliability.
                    Test the system's ability to handle expected transaction volumes.
            Economic Feasibility: Economic feasibility determines if the projected benefits of the system outweigh its estimated costs, considering total cost of ownership (TCO) and return on investment (ROI).
                Why (For What):
                    To ensure the project is financially viable.
                    To determine if the investment will "pay off."
                How:
                    Identify all costs, including development, maintenance, training, hardware, and licensing.
                    Calculate ROI:
                    ROI = (Net Profit / Total Costs) × 100
                    Example: If net profit is $20,000 and total costs are $10,000:
                    ROI = (20,000 / 10,000) × 100 = 200%.
                    Compare costs to projected benefits (financial and operational).
            Schedule Feasibility: Schedule feasibility evaluates whether the project can be completed within an acceptable or established time frame.
                Why (For What):
                    To ensure the project can meet deadlines without sacrificing quality.
                    To identify risks associated with tight schedules.
                How:
                    Determine if management has set a firm deadline.
                    Assess risks associated with an accelerated schedule.
                    Appoint a project manager to oversee timelines.
                    Create a detailed project schedule with milestones and deadlines.
        Why (For What):
            To prioritize projects based on their potential for success and alignment with business goals.
            To avoid pursuing projects that are not viable.
        How:
            Define the problem or opportunity.
            Assess the project against each feasibility dimension.
            Prepare and present a feasibility report to stakeholders.
    
    ~ADEPT Analysis for Moguls‘N Stuff Ski School Scheduling System:
        : ACTIVITIES (Business Processes): What is happening?
            The Moguls‘N Stuff Ski School Scheduling System organizes student lesson requests and assigns instructors accordingly. The key activities include:
                Student Requests Submission – Students place lesson requests into the Request file folder.
                Daily Request Check – A clerk reviews the file daily to determine if enough students have requested a particular lesson.
                Instructor Assignment – If the student count meets the minimum requirement, the clerk checks for available instructors.
                Instructor Confirmation – The clerk contacts instructors with lesson details, and the instructor either accepts or rejects the teaching assignment. If an instructor rejects, the next available instructor is contacted.
                Class List Preparation – Once an instructor accepts, the clerk compiles a class list using data from the Instructor, Request, and Lesson files.
                Filing & Notifications – The original class list is filed, a copy is sent to the instructor, and class confirmation letters are sent to students.
            How are these activities structured?
                A sequential process from request collection → instructor confirmation → class list generation → student notification.
                A decision-making component where the instructor can accept or reject the lesson.
                Multiple interactions between the clerk, instructors, and students.
        : DATA (Information Used & Generated): What data is involved?
            Request File Folder – Contains student lesson requests.
            Lesson Information – Date, time, location, type of lesson, number of students.
            Instructor List – Contains availability and eligibility of instructors.
            Class List – Compiled when a class is scheduled and includes:
                Instructor Name
                Student Names
                Lesson Details (Date, Time, Location, Type of Lesson)
            Class Confirmation Letters – Sent to students with class details.
            How is the data managed?
                Paper-based system where files are manually reviewed.
                Manual tracking of instructor availability and student requests.
                Paper copies of the class list are stored in a file cabinet.
                Daily checks ensure timely scheduling and updates.
        : ENVIRONMENT (External & Internal Influences): Where does this system operate?
            Internally: The clerk manages scheduling within the ski school.
            Externally: Instructors and students are notified of class details.
                What external factors impact the system?
                    Weather conditions may affect lesson schedules.
                    Instructor availability (some may decline lessons).
                    Seasonal fluctuations in demand for ski lessons.
                    School policies on minimum student enrollment per class.
            Why is this system necessary?
                Ensures organized scheduling of lessons.
                Manages instructor availability efficiently.
                Notifies students in advance to confirm their lessons.
        : PEOPLE (Stakeholders & Users): Who is involved?
            Primary Actors:
                Students – Request ski lessons.
                Clerk – Manages scheduling, assigns instructors, and notifies students.
                Instructors – Accept or decline teaching assignments.
                Ski School Management – Oversees operations and ensures smooth scheduling.
            What roles do they play?
                The clerk is the central coordinator managing requests, instructor assignments, and notifications.
                Instructors confirm their availability and conduct the lessons.
                Students receive confirmation letters for their scheduled lessons.
            How do people interact with the system?
                Students submit requests manually.
                The clerk manually checks files and contacts instructors.
                Instructors respond (accept/reject) via communication from the clerk.
                Students receive class confirmation letters via traditional mail or email.
        : TECHNOLOGY (Tools & Infrastructure): What technology supports this system?
            Manual File System – Request folders, Instructor lists, and Lesson files.
            Basic Communication Tools – Phone calls or emails for instructor contact.
            Paper-Based Notifications – Class lists and confirmation letters.
            Physical Filing Cabinet – For storing original class lists.
            By what means does technology support the system?
                Minimal automation; the process is largely manual and paper-based.
                Telephone or email for instructor confirmation.
                Printed documents for class lists and notifications. 
~RISK MANAGEMENT: MITIGATION (BEFORE) & CONTINGENCY (AFTER) RISKS HAPPENS
    : Five Steps for Risk Management: A structured process for identifying, analyzing, and managing risks.
        Why (For What): To proactively manage risks and improve project success.
        How (By What Logical Steps):
            Collect business ramblings: Brainstorm potential risks with the team.
            Translate ramblings into risks: Reframe vague concerns into clear, actionable risk statements.
            Determine relevant risks: Filter out unlikely or irrelevant risks.
            Determine data-rule dependencies: Identify what data or processes are tied to each risk.
            Determine inter-rule relationships: Analyze how risks may interact or compound.

~DIVIDE/UNCERTAINTY: Random variable 
    : NOT-IN-NOT-OUT:
        Hide	| Block
        Mute	| Deafen
        Pause	| Detach
        Choke	| Mask
        Break	| Fast
    : Error/Flags     
        Collision/Network Congestion= conflict with transfer in carrier
            Routine Problem, Hop Limit
            Scrambled Packets
            Growing Wait-Time
        Kernel Panic/Crash, Overflow= not enough memory bit 
        Dirty Bit= Mismatch between Cache and RAM, Bugs, Worm, Malware 
    : Cybersecurity:
        : Threat Model, 
            : Attack vector
            : Brute Force Attack
        : Questions: 
            : Who are you?
            : What should you have access to?
            : What you have?
            : What you are?
        : Authentication
            : Passwords
            : 2/Multi-Factor
        : Premission:
            : Read = Allows a user to see the contents of a file
            : Write = Allows a user to modify the contents
            : Execute = Allows user to run a file
        : Malware:
            : 
        : Security Kernel =
            : Independent Verification & Validation
        : Isolation/Sandbox
        : Virtual Machine
    : Hackers: 
        : White Hats
        : Black Hats
        : Social Engineering
            : Phishing
            : Pre-texting
        : NAND Mirroring 
        : Malware:
            : Trojan Horse
        : Bug Exploits:
            : Buffer Overflow
            : Bounds Checking
            : Canaries
            : Code Injections
        : Zero Day Vulnerability
        : Security Patches 
        : DDos Attacks

    : Cryptography: Defense
        : Encription 
            : Symmetric
            : Asymmetric
                : Public
                : Private
        : Decryption
        : Ceasar Cipher
        : Cryptoanalyst
        : Subsctitution Cipher
        : Columnar Transposition Cipher
            : Enigma Rotor
            : The Bombe
        : Data Encryption Standard
            : Advanced Encryption Standard
        : Key Exchange
            : Diffie-Hellman
        : Modular Exponentiation
 
############################################################################################################################################################################################################
Analysis of "Attention Is All You Need" Paper Using the 5W1H Framework
    : The Transformer outperforms existing models in sequence transduction tasks, particularly in machine translation, while offering faster training times and increased parallelization.
    : Why Was the Transformer Created? (For What Risks and Challenges?)
        The Transformer was developed to overcome limitations of traditional sequence models like RNNs and CNNs, which suffer from:
            Slow Training: RNNs process tokens sequentially, limiting parallelization.
            Long-Term Dependency Problems: RNNs struggle with remembering distant information.
            High Computational Costs: CNNs require many layers to capture long-range dependencies.
            Inefficiency in Handling Long Sequences: Memory constraints make training large datasets difficult.
        The risk of not improving these architectures would have meant:
            Slower advancements in AI language models.
            More expensive computational requirements.
            Limited applicability of AI in real-time NLP tasks.
    : How Does the Transformer Work? (Logical Steps of Solution)
        Step 1: Encoder-Decoder Architecture
            The Transformer follows an encoder-decoder structure:
                Encoder: Processes the input sentence into a fixed representation.
                Decoder: Generates the output sequence, one word at a time.
        Step 2: Self-Attention Mechanism
            Instead of using RNNs, the Transformer calculates attention scores for all words in a sentence simultaneously.
            Multi-Head Attention enables different aspects of word relationships to be captured.
        Step 3: Positional Encoding
            Since Transformers do not process sequences sequentially, positional encoding is added to retain information about word order.
        Step 4: Feed-Forward Layers
            Each word's representation is passed through fully connected layers to extract deeper features.
        Step 5: Masked Self-Attention in the Decoder
            Prevents words from attending to future words (maintains causality).
        Step 6: Output Prediction
            The decoder predicts the next word using a softmax function, generating the final output.
        Step 7: Optimization and Training
            Uses the Adam optimizer with learning rate scheduling.
            Dropout and Label Smoothing are applied for regularization.
            Beam Search is used for better sentence generation.

###############################################################################################################################
~DATABASE FUNDAMENTALS:
    : DATABASE THEORY: Ensures efficient, consistent, and scalable database designs.
        : Relational Database Management System: A type of DBMS that organizes data into tables with rows and columns.
            : Business Rules: Define how tables relate to each other.
            : Entities: Real-world objects (e.g., Customer, Order).
                : Associative: a table used to represent many-to-many relationships between two entities. 
                    It includes the primary keys of both entities as foreign keys and may have additional attributes.
            : Attributes: Properties of entities. They have a domain, which is the set of valid values an attribute can assume 
                : Atomic: cannot be broken down further into meaningful parts (e.g., FirstName).
                : Composite: can be divided into smaller meaningful components (e.g., Address → Street, City, PostalCode).
                : Stored: physically stored in the database (e.g., DateOfBirth).
                : Derived: calculated or derived from other attributes (e.g., Age derived from DateOfBirth). 
                : Non-Key:
                : Repeating Group: An attribute that cannot be uniquely identified by the Primary Key in the table
                : Partial Dependency – An attribute(s) that can be uniquely identified by just part of a tables composite Primary Key. 
                    A table must have a composite Primary Key for a Partial Dependency to exist
                : Transitive Dependency – Non key Attribute(s) that can be uniquely identified by another non key attribute. 
                    A table must have 2 or more non key attributes for a Transitive Dependency to exist.
        : Keys:
            : Primary: is a unique identifier for each record in a table (e.g., CustomerID). 
            : Technical: is an artificial identifier created by the database designer when no natural unique attribute exists 
            : Composite (or Concatenated): is a primary key that consists of two or more attributes 
            : Foreign: an attribute in one table that references the primary key in another table to establish a relationship 
        : Relationships/Cardinality: Dependencies between entities (e.g., Customer places Order). 
            : Parent-Child: formed when the primary key of the parent table is referenced as a foreign key in the child table 
            : One-to-One (1:1): One instance of an entity is linked to one instance of another entity.
            : One-to-Many (1:N): One instance of an entity is linked to many instances of another entity.
            : Many-to-Many (M:N): Multiple instances of one entity are linked to multiple instances of another entity.
            : Transitive Dependencies: Non-Key: depend only on the primary key
            : Non-Identifying Relationship: 
            : Partial Dependencies
    : Database Design Process: The structured process of creating a database schema that supports application requirements.
        : Implement Foreign Keys: Use foreign keys, which connect the primary key of one entity to a field in another.
        : Handle Many-to-Many Relationships: Break them into two one-to-many relationships by creating an associative entity.
        : Use ERD notations (e.g., IDEF1X) to depict the schema.
            : Entity-Relationship Diagram (ERD): A graphical representation showing entities, attributes, and their relationships.
                : Include relationship labels and cardinality symbols for clarity.
                : Iteratively Refine the Design: Ensure the relationships meet business requirements and minimize data redundancy.
            : Entities: Represented as boxes with attributes inside.
            : Attributes:
                : Primary keys are listed above the line in an entity box.
                : Foreign keys are suffixed with "FK."
            : Relationships/ Symbols of Cardinality:
                : Dashed lines for non-identifying relationships.
                : Solid lines for identifying relationships.
     
    : NORMALIZATION: A process for organizing data to reduce redundancy and ensure consistency.
        ~1: Collect views(subsets of data) using source documents and business rules.
            : Initial Table: Identify Primary Key and repeating group(s) of attributes.
            : First Normal Form (1NF):
                Ensures that all columns contain atomic (indivisible) values.
                Eliminates repeating groups or arrays within a table.
                IMPORTANT: After 1NF, there should be never more than 2 entities/tables.
            : Second Normal Form (2NF):
                Builds on 1NF.
                Ensures all non-key attributes are fully dependent on the primary key.
                    - A violation can only occur in a table with a composite key
                Eliminates partial dependencies (dependencies on part of a composite primary key).
            : Third Normal Form (3NF):
                Builds on 2NF.
                Ensures no non-key attribute is dependent on another non-key attribute (removes transitive dependencies).
            
            : Boyce-Codd Normal Form (BCNF):
                A stricter version of 3NF.
                Ensures every determinant is a candidate key(i.e., no attribute can determine another unless it is part of a candidate key).
            : Fourth Normal Form (4NF):
                Eliminates multi-valued dependencies.
                Ensures that one column's value is not dependent on multiple values of another column.
            : Domain-Key Normal Form (DKNF):
                Theoretical "ultimate" form of normalization.
                Ensures no constraints exist other than key constraints and domain constraints.
                Rarely implemented due to its complexity.
        ~3: Merge

###############################################################################################################################
