~FLOW/MOTION-STATE: HABIT-LOOP= STIMULUS >>> REACTION(INSTANT-GRATIFICATION), RESULT(s, a): returns state after action a taken in state s
    : Brute Force, Selection, Merge, Dijkstra... 
    : IN:SEE/HEAR/FEEL/SMELL/TASTE(STIMULUS) - OUT:MIRROR/BE(SEEN/HEARD/FELT/SMELLED/TASTED)
    : In-Output Devices/Peripherals + Infrastructure: InternetDeepSeaCables, CopperWire/EthernetCable/RadioWaves/WiFi/Signals
		: Camera        = Screen, GUI, CRTs>Scanning>Pixels, DesktopMetaphor, 3DProjection,
		: Mic           = Speaker
		: Keyb/Mouse    = Animation/Events
		: Cooler        = Exhaust
		: Power         = Heat
    : Triggers/Conditionals: Enables decision-making in code. To perform actions based on conditions.
        : If/ElseIf/Else: Executes code based on logical conditions. To handle multiple outcomes.
        : Switch: Simplifies multi-condition branching. To streamline complex conditional logic.
        : Exception Handling: Manages runtime errors. To handle errors gracefully and ensure program stability.
    : Loops: Repeats code execution based on conditions. To perform repetitive tasks.
        : While: Repeats while a condition is true. To handle indefinite iteration.
        : Do-While: Executes at least once before checking conditions. To ensure at least one iteration.
        : For: Iterates a specific number of times. To handle definite iteration.
        : Continue Statement: Skips to the next iteration. To bypass unnecessary code in specific cases.
        : Break Statement: Exits a loop or switch statement early. To terminate iterations based on conditions.	
    : Return Statement: Exits a function and optionally returns a value. To end execution and provide a result.
        : Then/Else/Next... 
    : DATABASE ENGINE: The core set of programs in a DBMS that handles all database operations.
        : DATA DEFINITION LANGUAGE (CREATE, ALTER, DROP commands): Sets up the database structure for efficient storage.
        : SQL Queries (SELECT, WHERE, JOIN, AGGREGATE functions): Extract insights and support decision-making.
        : DATA MANIPULATION LANGUAGE (INSERT, UPDATE, DELETE statements): Keep datacase data updated and accurate.
        : STORED PROCEDURES (CREATE, PROCEDURE, parameters, transactions, and error handling): Improve performance and handle business logic efficiently.
        : TRIGGERS (CREATE TIGGER for INSERT, UPDATE, DELETE): Enforce rules and log/audit changes automatically.
 
~DECODE: 
    : Computer: Central/Graphical Processing Unit (C/GPU) >>> Transistors
        : Clock
        : Permanent Memory:  
            : Files System:
                : Directory = Name, Type, Root>Sub, Hierarchical/Flat, Metadata: Length, 
                    : Memory Size/Length: (4/8(byte)/16(word)/32/64/128)
            : File Types: Array, Libraries, Node/Tree, Graph/Web/Forest, 3D Matrix... 
                : Wave/Audio: Amplitude, Spectogram... 
                : Bitmap: GraphicsGenerator>ScreenBuffer(ImageWidthxHeight)
                : Character/Text/List/String = ASCII>UNICODE
                : Number/Integer/Float= 
                    : Scientific Notation; Negative Bit= 2^N-x
                    : Null
            : Knowledge(Known)/Facts:
                :
            : Memory Bit: BinaryStates = 0, 1 (Base-2 Notation)
                : Memory Address:
                    : Pointer: Next Address Reference
                    : Index
                : Instruction
        : Temporary Memory Registers:
            : Instruction-Address Register >>> Address Input >>> Address = Data in RandomAccessMemory (RAM) >>> Instruction Register: FETCH PHASE
                : Multiplexer: MUX = (a AND NOTsel) OR (sel AND b)
                    : NOT (in=sel, out=NOTsel)
                    : AND (in=a, in=NOTsel, out=aANDNOTsel)
                    : AND (in=sel, in=b, out=selANDb)
                    : OR (in=aANDNOTsel, in=selANDb, out=out)
                : Matrix >>> Gate >>> AND-OR Latch: Memory Address
                    : AND (in=column, in=row, out=columnANDrow)
                        : AND (in=data, in=write-enable, out=set)
                        : NOT (in=data, out=NOTdata)
                        : AND (in=NOTdata, in=write-enable, out=reset)
                            : OR (in=set, in=outLOOP, out=setORoutLoop)
                            : NOT (in=reset, out=NOTreset)
                            : AND (in=setORoutLOOP, in=NOTreset, out=out)
                : Memory Register/Bit: 
                    : OR-LOOP (in=a, in=b, out=1)
                    : AND-LOOP (in=a, in=b, out=0) 
            : Instruction Register decodes Data into OperationsCode (OPCODE): DECODE PHASE
            : Registers A, B, C... for loading values temporarily. 
        : Arithmetic Unit = Half>Full>Multi-bit Adder:
            : XOR (in=a, in=b, out=abSUM)
                : AND (in=a, in=b, out=aANDb);
                : NOT (in=aANDb, out=NOTaANDb);
                : OR (in=a, in=b, out=aORb);
                : AND (in=NOTaANDb, in=aORb, out=out);
            : AND (in=a, in=b, out=abCARRY)
                : >XOR (in=abSUM, in=c, out=abcSUM)
                : >AND (in=abSUM, in=c, out=abcCARRY)
                    ; >OR (in=abCARRY, in=abcBARRY, out=out)
        : Logic Unit: Mux/DMux >>> Xor >>> Or >>> And/Nand >>> Not
        : Flags of Bits: Overflow(>), Zero(=), Negative(<)...

~SOFTWARE: 
    : LAYERS OF THE OPEN SYSTEM INTERCONNECTION (OSI) MODEL: 
        : Physical Layer: Transistors convert digital signals (0s and 1s) into electrical, light, or radio waves
        : Data Link Layer: The frames are reassembled and validated for any transmission errors.
        : Network Layer: The packets are reassembled, and IP addresses are used to confirm the data arrived at the correct destination.
            : Internet Protocol (IP): Header = InternetServiceProvider(ISP)>Wide>LocalAreaNetwork>MAC Address
        : Transport Layer: Segments are reassembled, and any lost data is retransmitted.
            : Transmission Control Protocol (TCP): TCP Header = Software Port + Checksum
        : Application Layer: The data is handed off to the application that requested it, such as a web browser displaying a webpage.
            : Data Payload (UDP): Data
                : Domain Name System (DNS) + Web-Server Address: Universal Resource Locator (URL) + Hyperlinks
                : Web-Browser/Search-Engine: Hypertext Transfer Protocol (HTTP)
                    : Index: Frequency of Words
                    : Hypertext Markup Language (HTML) + CSS
   
    : NATURAL LANGUAGE PROCESSING:
        ~1: Define terminal and non-terminal symbols:
            N = {"she", "city", "car", "Harry"}  # Nouns
            V = {"walked", "saw"}  # Verbs
            D = {"the", "a", "an"}  # Determiners
        ~2: Define rewrite rules:
            NP → N | D N
            VP → V | V NP
            S → NP VP
        ~3: Use Natural Language Toolkit (NLTK) to parse sentences:
            import nltk
            grammar = nltk.CFG.fromstring("""
                S -> NP VP
                NP -> N | D N
                VP -> V | V NP
                N -> 'she' | 'city' | 'car' | 'Harry'
                V -> 'walked' | 'saw'
                D -> 'the' | 'a' | 'an'
            """)
            parser = nltk.ChartParser(grammar)
            sentence = "she saw the city".split()
            for tree in parser.parse(sentence):
                print(tree)
        ~4: Generate a syntax tree for valid sentences:
            (S
                (NP (N she))
                (VP (V saw) (NP (D the) (N city))))
        ~5: Expand with additional grammar rules (e.g., adjective phrases, prepositional phrases) to capture sentence complexity.
        
        : TRANSFORMERS ARCHITECTURE:
            : Encoder: input word + positional encoding >>> (multi-head self attention >>> neural network) * Number >>> encoded representation
            : Decoder: previous output word + positional encoding >>> (multi-head self attention >>> (encoded representations) attention >>> neural network) * Number >>> encoded representation
            ~1: Encoder-Decoder Architecture
                : Encoder: Processes the input sentence into a fixed representation.
                : Decoder: Generates the output sequence, one word at a time.
            ~2: Self-Attention Mechanism
                Instead of using RNNs, the Transformer calculates attention scores for all words in a sentence simultaneously.
                Multi-Head Attention enables different aspects of word relationships to be captured.
            ~3: Positional Encoding
                Since Transformers do not process sequences sequentially, positional encoding is added to retain information about word order.
            ~4: Feed-Forward Layers
                Each word's representation is passed through fully connected layers to extract deeper features.
            ~5: Masked Self-Attention in the Decoder
                Prevents words from attending to future words (maintains causality).
            ~6: Output Prediction
                The decoder predicts the next word using a softmax function, generating the final output.
            ~7: Optimization and Training
                Uses the Adam optimizer with learning rate scheduling.
                Dropout and Label Smoothing are applied for regularization.
                Beam Search is used for better sentence generation.

    : NEURAL NETWORKS:
        ~1: Define Inputs & Outputs: "We begin with defining the input variables x1,x2,...xnx1​,x2​,...xn​ and setting up the desired outputs." (Neural Networks, p. 3).
        ~2: Assign Weights & Biases: "Each input is multiplied by a corresponding weight, with an additional bias term." (Neural Networks, p. 4).
        ~3: Apply Activation Function: "An activation function is applied to determine when a neuron becomes active." (Neural Networks, p. 6).
        ~4: Calculate Output: "The network then processes the weighted sum of inputs and passes it through layers to get the final output." (Neural Networks, p. 7).
        ~5: Train the Network Using Backpropagation: "Gradient descent is used to adjust the weights to minimize the loss function." (Neural Networks, p. 15).
    
    : LEARNING: 
        : Supervised learning = given a data set of input-output pairs, learn a function to map inputs to outputs
            ~1: Prepare Data: Collect labeled input-output pairs.
            ~2: Split Data: Divide into training and testing sets.
            ~3: Train Model: Fit a hypothesis function to the training data.
            ~4: Evaluate Model: Test the trained model on unseen data.
            ~5: Adjust Weights: Update parameters based on accuracy.
            : reinforcement learning = given a set of rewards or punishments, learn what actions to take in the future
            : unsupervised learning = given input data without any additional feedback, learn patterns
        : Nearest Neighbor Classification: A simple supervised learning method where classification is based on the closest labeled data points: 
            ~1: Store all training data.
            ~2: For a new input:
                : Compute distance to all stored points.
                : Select the closest k neighbors.
                : Assign the most common class among neighbors.
            ~3: Output the predicted class.
        : Perceptron Learning: A linear model that adjusts weights iteratively based on errors in classification:
            ~1: Initialize weights randomly.
            ~2: For each data point (x, y):
                : Compute prediction using dot product.
                : Compare prediction with actual output.
                : If incorrect, adjust weights: wi=wi+α(y−y^)xi
            ~3: Repeat until convergence.

    : OPTIMIZATION: the process of selecting the best option from a set of possible choices to achieve a specific goal efficiently. It involves techniques such as local search, hill climbing, simulated annealing, and linear programming.
        : Hill Climbing: algorithm follows a simple logic:
            ~1: Start with an initial state.
            ~2: Evaluate neighboring states.
            ~3: Move to the best neighbor if it improves the solution.
            ~4: Repeat until no better neighbor exists.
        : Simulated Annealing: introduces randomness in the search process by sometimes accepting worse states, with decreasing probability over time.
        : Linear Programming is used for problems where constraints must be satisfied while minimizing or maximizing a cost function.
    
    : CERTAINTY: inability of artificial intelligence to have perfect knowledge about the world, requiring it to operate based on probabilities rather than certainties
        : Conditional Probability Calculation: To determine P(A | B) (the probability of A given B), we use the formula:
            P(A∣B)=P(A∩B)P(B)
            P(A∣B)=P(B)P(A∩B)​ 
        : Sampling for Approximate Inference: When exact calculations are computationally expensive, we can approximate probabilities by generating many random samples.

        : Bayes' Rule: P(b | a) = P(a | b) P(b) / P(a)
        : Probability Rules:
            : Negation
            : Inclusion-Exclusion
            : Marginalization
            : Conditioning
        : Inference by Enumeration
        : Approximate Inference:
        : Sampling
            : Rejection Sampling
            : Likelihood Weighting
        : hidden Markov Model: Task:
            : Filtering = given objservations from start until now, calculate distribution for current state
            : prediction = given observations from start until now, calculate distribution for a future state
            : smoothing = given observations from start until now, calculate distribution for past state
            : most likely explanation = given observatinos from start until now, calculate most likely sequence of states
    
    : KNOWLEDGE:
        : INFERENCE BY RESOLUTION:
            ~1: Convert all knowledge into Conjunctive Normal Form (CNF):
                : Remove biconditionals (↔) and implications (→).
                : Apply De Morgan’s Laws to push NOT operators inward.
                : Distribute OR over AND to standardize logical clauses.
            ~2: Assume the negation of the query (¬Q).
            ~3: Use Resolution Inference:
                : Find clauses with complementary literals (P and ¬P).
                : Resolve them to create new clauses.
                : Repeat until empty clause (∅) is derived (indicating a contradiction).
            ~4: If an empty clause is found, the query is true; otherwise, it's false.

    : SEARCH/Queries: Retrieves specific data from the database. To access and analyze stored information.
        ~1: Define Initial State: Start with a known state.
        ~2: Check Goal State: Verify if the current state meets the goal criteria.
        ~3: Expand Nodes: Generate possible next states from the current state.
        ~4: Store in Frontier: Maintain a list of unexplored nodes.
        ~5: Use Search Strategy: Choose the next state based on the algorithm.
        ~6: Avoid Infinite Loops: Track visited states to prevent redundant exploration.
        ~7: Find Optimal Solution: Minimize path cost if applicable.
            : DEPTH-FIRST SEARCH:
                ~1: Push Initial State into Stack Frontier.
                ~2: Loop until Solution or Empty Frontier:
                    : Pop the last added node.
                    : If goal state, return solution.
                    : Otherwise, expand node and push new nodes into the stack.
                ~3: Backtrack when dead ends are reached.
            : BREADTH-FIRST SEARCH:
                ~1: Enqueue Initial State into Queue Frontier.
                ~2: Loop until Solution or Empty Frontier:
                    : Dequeue the first added node.
                    : If goal state, return solution.
                    : Otherwise, expand node and enqueue new nodes.
            : A* SEARCH: 
                ~1: Initialize Priority Queue Frontier with Initial State.
                ~2: Loop until Solution or Empty Frontier:
                    : Remove the node with the lowest f(n) = g(n) + h(n).
                    : If goal state, return solution.
                    : Otherwise, expand node and add new nodes with updated f(n).    
            : MINIMAX ALGORITHM (For Adversarial Search) 
                ~1: Recursively Explore Possible Moves.
                ~2: If Terminal State, Return Utility.
                ~3: If Max Player, Choose Move with Maximum Utility.
                ~4: If Min Player, Choose Move with Minimum Utility. 

    ~FREE-WILL: STOP-&-CORRECT = NOT-IN:BLINK/DEAFEN/FLEE/MASK/FAST() - NOT-OUT:HIDE/MUTE/PAUSE/BLOW/SPIT()
        ~READ/LOAD(FRONTIER), MEMORY/CATEGORIES/EXPLORED-SET; TERMINAL(s): checks if state s is a terminal state; "Is Frontier Goal?"
           : Categorize:
                : SYNTAX: SENTENCE, STORYLINE= ARISTOTLE'S RHETORIC
                : WORD: PARSE/ETYMOLOGY
                    : Roots: Fact/Known
                        : WHEN: SCHEDULE= Start*Finish... ClockCycle/Hertz/Second/Minute/Hour/Day/Month/Season/Year...: CHRONOLOGY
                        : WHERE: HOME= Length*Width*Height... Checkpoint/Position/Address/Continent/Sea/Climate...: ASTRONOMY (PTOLEMY), GEOGRAPHY
                        : WHO: FAMILIAR= Mother*Father... Blood/Tribe/Ethnicity/Race/Specie/Genus/Status...: Personality Types / Characters (Theophrastus)
                        : WHAT: KNOWN= Contract & Copy Writing, Financial Statement...
                    : Fixes: Position-Lodial
                : SYMBOLS: Flags, International Beaureau of Weights and Measures in France
                    : Letters/Spells, 
                    : Metals, Conductors,
                    : Light: GEOMETRY (EUCLID)
                    : Sound: MUSIC (BOETHIUS)
                    : Motion: PHYSICS (ARISTOTLE)
                    : Energy: path cost function: number of steps in proof
                        : Positive (+1): +1=FRUIT/HERO/WAY/CHANCE FOR-BY SEEDWORD/FATHERGOD/KINGDOMHEAVEN/DEATHEND
                        : Negative (-1): -1=SPOIL/SACRIFICE/TRAP/WAIT FOR-BY SOILVOID/MOTHERBEAST/WILDWORLD/BIRTHSTART
                        : Neutral (0): 0=EXPERIENCE/CHILD/CONTACT/LIFE: UTILITY(s): final numerical value for terminal state s
                            : ~AGENT/PLAYER/CORPORATION: BODY/I/HERE/NOW: knowledge-based agent(s) that reason by operating on knowledge
       
        ~WRITE/ARRANGE()-ERASE-FORGET(BABBLE/WRONG)/CRUD, CORRECTNESS/REASON:
            : ARISTOTLE'S NICHOMACHEAN ETHICS
            : POSTAL MECHANICS + MARITIME LAW + ROBERT'S RULE OF ORDER
            : NOW-SPACE 
            : CORRECT-PARSE-SYNTAX-GRAMMAR: POSITION-LODIAL-FACT
                : FOR THE KNOWLEDGE OF THE FACT IS WITH THE PERFORMANCE BY THE AUTHORITY.
            : List: Queue/Stack, 
            : LOGIC-ARITHMETIC = -1, 0, +1
                : Arithmetic: XOR+ANDCarry/Half, Full, Multi-bit Adder
                : Logic: NOT, AND, OR
 
~INFORMATION SYSTEMS: Core components that make up an information system (IS), including data, hardware, and software.
    Define the system’s purpose and scope.
    Identify and integrate hardware components (physical systems).
    Develop and implement software (programs controlling the hardware).
    Collect and process input data to achieve specific results.
        Use data from enterprise systems.
            Monitor trends and forecast growth.
            Allocate resources effectively.
        Use MIS and DSS for insights.
            Plan resources and delegate tasks.
            Perform analysis and generate reports.
        Oversee staff and operations.
            Provide immediate feedback.
            Use TPS for monitoring workflows.
        Enter data into TPS.
            Process tasks (e.g., reservations, orders).
            Rely on automated systems for efficiency.
        
    ~BUSINESS USE OF INFORMATION TECHNOLOGY: How IT is used to support different business operations and decision-making processes.
        1. Enterprise Computing Systems: Systems that support company-wide operations and strategic decision-making (e.g., ERP systems).
            Implement structured rules for predictable tasks.
            Use ERP to consolidate operations into a single system.
            Ensure scalability for future growth.
        2. Transaction Processing Systems (TPS): Applications that handle daily operations like orders, reservations, and payroll.
            Collect input data for transactions.
            Process data in real-time or batch mode.
            Produce outputs for operations (e.g., receipts, records).
        3. Business Support Systems (MIS): Systems for generating management reports to aid decision-making.
            Collect data from TPS or other sources.
            Generate detailed, summary, or exception reports.
            Use reports for analysis and decision-making.
        4. Decision Support Systems (DSS): Tools for performing “what-if” analyses and making decisions.
            Analyze data using simulations.
            Present insights with interactive dashboards.
            Test multiple scenarios to identify optimal solutions.
        5. Knowledge Management Systems (KMS): Advanced systems using expert knowledge to simulate reasoning and provide solutions.
            Build a knowledge base with encoded rules.
            Use fuzzy logic to manage imprecise relationships.
            Apply inference rules for decision-making.
    
    ~FUNCTIONAL REQUIREMENTS: define what the system is supposed to do. They describe specific behaviors, actions, or tasks the system must perform, focusing on inputs, processing, and outputs.
        ~1: Identify the core objectives and purpose of the system.
        ~2: Gather input from stakeholders and users regarding what tasks the system must perform.
        ~3: Document specific system actions and interactions, such as:
            : Business rules.
            : Authentication and authorization processes.
            : Transaction processing (corrections, adjustments, cancellations).
            : Audit tracking and external interfaces.
        ~4: Test functionality to verify the system performs as defined.
            Examples:
            A banking system must allow users to transfer funds (Transaction Processing).
            A website requires users to log in with a username and password (Authentication).
            A system must record and store data changes for future reference (Audit Tracking).
    ~NON-FUNCTIONAL REQUIREMENTS: Non-functional requirements specify how the system performs its tasks. They focus on qualities such as performance, reliability, usability, and scalability rather than specific behaviors.
        ~1: Define quality standards and expectations for the system.
        ~2: Identify specific non-functional requirements, such as:
            : Performance (response times, system throughput).
            : Scalability (ability to handle growth in users or data).
            : Security (data protection, access control).
            : Usability (ease of use for end users).
        ~3: Develop and implement system architecture to meet these requirements.
        ~4: Test the system to verify non-functional attributes under various scenarios (e.g., load testing, recovery testing).
            Examples:
            The system should handle 10,000 simultaneous users (Scalability).
            Data recovery must occur within 2 hours after a system crash (Recoverability).
            The system should respond to user requests within 2 seconds (Performance).
    
    ~COMPARISON: Functional vs. Non-Functional Requirements
        Aspect	    Functional Requirements	                                Non-Functional Requirements
        What it defines	What the system does.	                            How the system performs its tasks.
        Focus	    Features and user requirements.                         System quality and operational attributes.
        Examples	Transaction processing, authentication, audit tracking. Performance, scalability, reliability, usability.
        Impact	    System won’t function if unmet.	                        System still functions, but quality may be compromised.
        Testing	    Validate features and tasks.	                        Validate performance and reliability under different conditions.
        Conclusion:
        Why Both Are Important:
            Functional Requirements ensure the system performs its intended tasks.
            Non-Functional Requirements ensure the system performs efficiently, securely, and reliably, improving user satisfaction and long-term operational success.
        How to Address Both:
            Document functional requirements first to define system behavior.
            Develop non-functional requirements to establish quality standards.
            Use iterative testing to ensure compliance with both types of requirements.
    
    ~BUSINESS RULES: A business rule is a statement that defines or influences how a business operates. It governs decisions, processes, and behavior within an organization. Business rules:
        Why (For What):
            To maintain consistent operations and decision-making.
            To enforce organizational policies and legal requirements.
            To automate processes and reduce reliance on human judgment.
            To create new knowledge by systematically applying rules to existing data.
        How (By What Logical Steps):
            Define the behavior or decision the rule governs.
            Observe and document implicit and explicit rules (some may not be written).
            Integrate these rules into business processes or systems.
            Ensure the rule is clear, justified, and enforceable.
            Test the rule in real-world scenarios to ensure it works as intended.
        How Does That Work?
            Example: Hotel Reservation Rule
            What: A customer cannot check in without a reservation.
            Who: Hotel clerks enforce the rule, and the hotel’s booking system supports it.
            Where: At the hotel’s front desk during check-in.
            When: When a customer arrives to check in without prior reservation.
            Why (For What): To ensure efficient room allocation and avoid overbooking.
            How:
                The clerk asks if the customer has a reservation.
                If not, the clerk creates a reservation in the system.
                The customer is then checked in, satisfying the business rule.
        
        ~PROPERTIES OF A GOOD BUSINESS RULE: A good business rule should meet specific criteria to ensure clarity, enforceability, and alignment with business objectives.
            Why (For What): To ensure rules are actionable, clear, and relevant to organizational goals.
            How (By What Logical Steps):
                Atomic: Ensure the rule focuses on a single concept or action.
                    Example: "We only ship complete orders."
                Declarative: Specify when and how the rule applies.
                    Example: "Before a work order can be completed, a customer’s information must be collected."
                Precise: Avoid ambiguity or multiple interpretations.
                    Example: "Any customer that owes more than $5,000 cannot place new orders."
                Justified: Confirm the rule supports business objectives.
                Authorized: Ensure the rule is created by someone with decision-making authority.
        
        ~BUSINESS RULE EXAMPLES: Practical examples that demonstrate how business rules guide actions and processes.
            Examples:
                Everyone under the age of 25 must have their ID checked (compliance rule).
                Orders are only shipped when complete (operational rule).
                Customers with debts over $5,000 cannot place new orders (financial rule).
                Vehicles must be visually inspected for damage before release (safety rule).
            Why (For What): To ensure compliance, efficiency, safety, and financial prudence.
            How:
                Define the rule clearly.
                Train staff and configure systems to enforce the rule.
                Monitor adherence and adjust as needed.

    ~SYSTEM DESIGN: DEVELOPMENT LIFECYCLE:
        : Requirement Gathering: CLIENT INTERVIEWING is a technique used during the requirements-gathering phase 
            The objective is to collect accurate, complete, and specific information about the client’s needs, their business processes, and how a system can improve those processes. This includes identifying workflows, data storage practices, user needs, and system functionality.
            HOW (BY WHAT LOGICAL STEPS):
                Prepare for the Interview:
                    Research the business: Understand their workflows, current system, and competitive landscape.
                    Identify stakeholders to interview (users, supervisors, decision-makers).
                    Develop a list of targeted questions tailored to the client’s operations.
                Conduct the Interview:
                    Start with open-ended questions: Get a general understanding of workflows and goals.
                    Dive deeper with specific queries:
                        How is data stored and accessed?
                        What physical and digital documents exist?
                        What triggers activities (e.g., time, requests, documents)?
                        Who performs the work? Are they users or information receivers?
                    Address business details: Operating hours, equipment, and competitors.
                    Use a structured approach like role-play, use cases, and scenarios when clients struggle with articulating needs.
                Overcome Communication Barriers:
                    For limited client perspectives:
                        Analyze their role, responsibilities, and system usage.
                        Explain the broader context of the system to clarify its impact.
                    For resistance to the project:
                        Conduct group interviews with supervisors present.
                        Record sessions for accuracy.
                        Ask direct and detailed questions, avoiding reliance on volunteered information.
                    For technical document misunderstandings:
                        Simplify the language and explain diagrams like Data Flow Diagrams (DFDs).
                        Walk through processes step-by-step to connect system actions to real-world operations.
                    For high-level, vague feedback:
                        Ask detailed questions about specific functionality or design elements.
                        Provide examples to guide input (e.g., "Are the filter options sufficient for your search?").
                Validate Findings:
                    Confirm the interview results through prototypes, role-play, or group reviews.
                    Ensure all activities, data flows, and user needs are verified.
                    Check if additional details are needed.
                Iterate and Refine:
                    Revisit unclear or incomplete requirements.
                    Use feedback from labs and prototypes to refine system understanding.
        : Planning + Design: Survey-Prove Investors
        : Prototyping (Testing) Development: FAIL FAST!
        : Deployment: Proven Product
        : Maintenance/Warranty
    : Source Control
        : Quality Assurance
        ; Roll Back
    : Repository:
        : Check in vs out
        : Committing

    ~SYSTEM DEVELOPMENT LIFE CYCLE (SDLC): A structured process used for planning, creating, testing, and deploying an information system. 
        System Planning:
            Identify and prioritize system needs.
            Define the scope and boundaries of the problem.
        System Analysis:
            Build a logical model.
            Analyze current problems and their root causes.
            Define and document business requirements.
        System Design:
            Design solutions (physical models, user interfaces, controls, and security).
            Produce a technical design document.
        System Implementation:
            Develop and deploy the system.
            Train users and create documentation.
            Plan conversion strategies (e.g., parallel, pilot, phased, or direct cutover).
        System Operation and Support:
            Monitor and maintain the system.
            Refine the system design and address issues.
            Ensure continued functionality throughout its useful life.
    
    ~SYSTEM DEVELOPMENT TOOLS/TECHNIQUES: Graphical representations of systems to visualize processes, data, and interactions.
        How: Create models like:
            Data Flow Diagrams (DFDs)
            Entity-Relationship Diagrams (ERDs)
            Unified Modeling Language (UML) diagrams.
    
    Prototyping: Building early, functional models of the system for testing and feedback.
        How:
            Develop prototypes based on requirements.
            Test feasibility and gather feedback.
            Iterate to improve before production.
    
    CASE Tools: Software tools for automating and assisting in system development.
        How: Use CASE tools to:
            Generate designs automatically.
            Standardize methodologies.
            Enhance collaboration and documentation.

    Five Steps for Creating a Business Rule Collection: A structured approach to defining and managing a set of business rules.
        Collect business ramblings: Gather informal or implicit rules by observing operations and interviewing stakeholders.
        Translate these ramblings into business rules: Reword them into clear, structured statements.
            Example: "Orders must be shipped complete."
        Determine which rules are relevant to project objectives: Filter out irrelevant or outdated rules.
        Determine data-rule dependencies: Identify which data elements the rules depend on (e.g., customer age, reservation status).
        Determine inter-rule relationships: Map how rules interact or overlap to avoid conflicts.

~RISK ANALYSIS: Risk management is an integral part of project planning to prevent small issues from escalating into emergencies.
    What: Risk is composed of five key elements:
        Event: What could happen?
        Probability: How likely is the event to happen?
        Impact: How bad will it be if it happens?
        Mitigation: How can the probability be reduced?
        Contingency: How can the impact be reduced if it does happen?
     Why (For What):
        Risk refers to the potential positive or negative effects of an event or series of events on a project. 
        It encompasses uncertainty and its impact on project outcomes.
        To anticipate potential problems and avoid or minimize their effects.
        To take advantage of positive risks (opportunities) when they occur.
        To ensure smooth project execution.
        To avoid budget overruns, missed deadlines, or project failure.
        To build proactive strategies for unforeseen challenges.
        To create structured strategies for managing risks.
        To minimize the impact of negative events and maximize the potential of positive ones.
     How (By What Logical Steps):
        Define risks that could affect the project.
        Categorize risks as opportunities or threats.
        Assess their likelihood and potential impact.
        Develop mitigation and contingency strategies.
        Monitor risks throughout the project lifecycle.
        Include risk analysis as part of the project planning process.
        Continuously update the risk register as new risks are identified.
        Regularly evaluate risks to keep the project on track.
            Identify potential risks (events) in the project.
            Assign a probability (High, Medium, Low) to each event.
            Assess the impact of each event on the project.
            Develop mitigation strategies to lower the likelihood of occurrence.
            Develop contingency plans to reduce the impact if the event occurs.
    
    Creating a Risk List: A risk list is a prioritized collection of potential project risks, detailing their probability, impact, and mitigation/contingency plans.
        Describe the risk event briefly (1–2 sentences).
        Assign a probability (High, Medium, Low) to each risk.
        Develop mitigation strategies to reduce the likelihood of high/medium probability risks.
        Assess the impact (High, Medium, Low) of each risk.
        Develop contingency plans to address the impact if the risk materializes.
    Assessing Probability and Impact
        Use a High, Medium, Low scale to categorize probability and impact.
        Address high-probability and high-impact risks first.
        Continuously re-evaluate risks as the project progresses.

    : Example of a Risk Event
        Why (For What): To avoid delays and ensure the project stays on schedule.
        How:
            Identify the risk event (parts delay).
            Assign Medium probability and High impact.
            Mitigate by ordering parts early in the project.
            Create a contingency plan to use existing parts temporarily.
    : Structured Analysis: A traditional methodology for breaking down system functions into detailed processes.
        Why: To ensure thorough understanding and structured documentation.
        How: Use tools like DFDs and process models to detail workflows.
    : Object-Oriented Analysis: A methodology that focuses on defining systems in terms of objects and their interactions.
        Why: To simplify design and enhance flexibility.
        How: Define objects, their properties, behaviors, and relationships.
    : Joint Application Development (JAD): Collaborative workshops for stakeholders to define requirements and design solutions.
        Why: To ensure alignment between business needs and technical solutions.
        How: Conduct structured sessions with stakeholders to gather input and refine requirements.
    : System Modeling: Modeling involves creating structured representations of a system to understand, analyze, and solve problems effectively.
        Why (For What):
            To provide structure to problem-solving.
            To explore multiple solutions efficiently.
            To abstract and simplify complex systems.
            To reduce development time and costs.
            To minimize risks and errors.
        How (By What Logical Steps):
            Identify the problem or system to be modeled.
            Define the goals of modeling (e.g., risk reduction, clarity).
            Create and test models using diagrams, simulations, or prototypes.
            Refine models based on feedback and iterations.

    : Feasibility: refers to assessing whether a proposed project is practical, achievable, and worthwhile to pursue. A feasibility study evaluates the potential success of a project across multiple dimensions.
        Define the project scope and objectives.
        Identify and evaluate feasibility criteria (operational, technical, economic, schedule).
        Collect data through interviews, surveys, and research.
        Analyze the data and prepare a feasibility report.
        Make a recommendation based on the findings.

    : Feasibility Study: A feasibility study is an ongoing process of tests to evaluate if a project is desirable, practical, and achievable. It ensures a project meets the following criteria:
        Operational feasibility: Operational feasibility evaluates whether the proposed system will be used effectively once implemented.
            Evaluate if management supports the project.
            Assess workforce impacts (e.g., training, reductions).
            Determine user involvement in planning and implementation.
            Identify potential customer effects and risks to company image.
            Check for conflicts with other organizational priorities.
        Technical feasibility: Technical feasibility examines the availability and adequacy of technical resources (hardware, software, expertise) to support the proposed system.
            Assess the availability of required hardware and software.
            Determine if the company has the technical expertise for development and maintenance.
            Evaluate platform capacity for scalability and reliability.
            Test the system's ability to handle expected transaction volumes.
        Economic Feasibility: Economic feasibility determines if the projected benefits of the system outweigh its estimated costs, considering total cost of ownership (TCO) and return on investment (ROI).
            Identify all costs, including development, maintenance, training, hardware, and licensing.
            Calculate ROI:
            ROI = (Net Profit / Total Costs) × 100
            Example: If net profit is $20,000 and total costs are $10,000:
            ROI = (20,000 / 10,000) × 100 = 200%.
            Compare costs to projected benefits (financial and operational).
        Schedule Feasibility: Schedule feasibility evaluates whether the project can be completed within an acceptable or established time frame.
            Determine if management has set a firm deadline.
            Assess risks associated with an accelerated schedule.
            Appoint a project manager to oversee timelines.
            Create a detailed project schedule with milestones and deadlines.
        Define the problem or opportunity.
        Assess the project against each feasibility dimension.
        Prepare and present a feasibility report to stakeholders.
    
    ~ADEPT Analysis for Moguls‘N Stuff Ski School Scheduling System:
        : ACTIVITIES (Business Processes): What is happening?
            How are these activities structured?
                A sequential process from request collection → instructor confirmation → class list generation → student notification.
                A decision-making component where the instructor can accept or reject the lesson.
                Multiple interactions between the clerk, instructors, and students.
        : DATA (Information Used & Generated): What data is involved?
            How is the data managed?
                Paper-based system where files are manually reviewed.
                Manual tracking of instructor availability and student requests.
                Paper copies of the class list are stored in a file cabinet.
                Daily checks ensure timely scheduling and updates.
        : ENVIRONMENT (External & Internal Influences): Where does this system operate?
            Internally: The clerk manages scheduling within the ski school.
            Externally: Instructors and students are notified of class details.
                What external factors impact the system?
                    Weather conditions may affect lesson schedules.
                    Instructor availability (some may decline lessons).
                    Seasonal fluctuations in demand for ski lessons.
                    School policies on minimum student enrollment per class.
        : PEOPLE (Stakeholders & Users): Who is involved?
            How do people interact with the system?
                Students submit requests manually.
                The clerk manually checks files and contacts instructors.
                Instructors respond (accept/reject) via communication from the clerk.
                Students receive class confirmation letters via traditional mail or email.
        : TECHNOLOGY (Tools & Infrastructure): What technology supports this system?
            By what means does technology support the system?
                Minimal automation; the process is largely manual and paper-based.
                Telephone or email for instructor confirmation.
                Printed documents for class lists and notifications. 
~RISK MANAGEMENT: MITIGATION (BEFORE) & CONTINGENCY (AFTER) RISKS HAPPENS = Five Steps for Risk Management: A structured process for identifying, analyzing, and managing risks.
        Why (For What): To proactively manage risks and improve project success.
        How (By What Logical Steps):
            Collect business ramblings: Brainstorm potential risks with the team.
            Translate ramblings into risks: Reframe vague concerns into clear, actionable risk statements.
            Determine relevant risks: Filter out unlikely or irrelevant risks.
            Determine data-rule dependencies: Identify what data or processes are tied to each risk.
            Determine inter-rule relationships: Analyze how risks may interact or compound.

~DIVIDE/UNCERTAINTY: Random variable 
    : NOT-IN-NOT-OUT:
        Hide	| Block
        Mute	| Deafen
        Pause	| Detach
        Choke	| Mask
        Break	| Fast
    : Error/Flags     
        Collision/Network Congestion= conflict with transfer in carrier
            Routine Problem, Hop Limit
            Scrambled Packets
            Growing Wait-Time
        Kernel Panic/Crash, Overflow= not enough memory bit 
        Dirty Bit= Mismatch between Cache and RAM, Bugs, Worm, Malware 
    : Cybersecurity:
        : Threat Model, 
            : Attack vector
            : Brute Force Attack
        : Questions: 
            : Who are you?
            : What should you have access to?
            : What you have?
            : What you are?
        : Authentication
            : Passwords
            : 2/Multi-Factor
        : Premission:
            : Read = Allows a user to see the contents of a file
            : Write = Allows a user to modify the contents
            : Execute = Allows user to run a file
        : Malware:
            : 
        : Security Kernel =
            : Independent Verification & Validation
        : Isolation/Sandbox
        : Virtual Machine
    : Hackers: 
        : White Hats
        : Black Hats
        : Social Engineering
            : Phishing
            : Pre-texting
        : NAND Mirroring 
        : Malware:
            : Trojan Horse
        : Bug Exploits:
            : Buffer Overflow
            : Bounds Checking
            : Canaries
            : Code Injections
        : Zero Day Vulnerability
        : Security Patches 
        : DDos Attacks
    : Cryptography: Defense
        : Encription 
            : Symmetric
            : Asymmetric
                : Public
                : Private
        : Decryption
        : Ceasar Cipher
        : Cryptoanalyst
        : Subsctitution Cipher
        : Columnar Transposition Cipher
            : Enigma Rotor
            : The Bombe
        : Data Encryption Standard
            : Advanced Encryption Standard
        : Key Exchange
            : Diffie-Hellman
        : Modular Exponentiation
 