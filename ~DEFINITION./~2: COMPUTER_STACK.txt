~MODERN COMPUTER STACK: Transistor - Web Browser
~HARDWARE: 
    : Infrastructure: InternetDeepSeaCables, CopperWire/EthernetCable/RadioWaves/WiFi/Signals
	: In-Output Devices/Peripherals:
		: See/Camera      = Show/Screen, GUI, CRTs>Scanning>Pixels, DesktopMetaphor, 3DProjection,
		: Hear/Microphone = Speak/Speaker
		: Feel/Keyb/Mouse = Move/Animation/Events
		: Inhale/Cooler   = Exhale/Exhaust
		: Eat/Power       = Create/Heat/PowerSupply
        : Router+Swtich, 
    : Computer:
        : More Bits for more Instruction/Memory Length:
            : Parallelization > Instruction Pipelining > Pipelined Superscalar > Multi-core CPU's
        : Central/Graphical Processing Unit (C/GPU): 
            : Clock
            : Temporary Memory Registers:
                : Instruction Address Register >>> Address Input >>> Address = Data in RandomAccessMemory (RAM) >>> Instruction Register: FETCH PHASE
                    : Multiplexer: MUX = (a AND NOTsel) OR (sel AND b)
                        : NOT (in=sel, out=NOTsel)
                        : AND (in=a, in=NOTsel, out=aANDNOTsel)
                        : AND (in=sel, in=b, out=selANDb)
                        : OR (in=aANDNOTsel, in=selANDb, out=out)
                    : Matrix >>> Gate >>> AND-OR Latch: Memory Address
                        : AND (in=column, in=row, out=columnANDrow)
                            : AND (in=data, in=write-enable, out=set)
                            : NOT (in=data, out=NOTdata)
                            : AND (in=NOTdata, in=write-enable, out=reset)
                                : OR (in=set, in=outLOOP, out=setORoutLoop)
                                : NOT (in=reset, out=NOTreset)
                                : AND (in=setORoutLOOP, in=NOTreset, out=out)
                    : Memory Register/Bit: Flip Flops: out[t] = in[t-1]
                        : OR-LOOP (in=a, in=b, out=1)
                        : AND-LOOP (in=a, in=b, out=0) 
                : Instruction Register decodes Data into OperationsCode (OPCODE): DECODE PHASE
                    : Load 
                    : Arithmetic = Half>Full>Multi-bit Adder:
                        : XOR (in=a, in=b, out=abSUM)
                            : AND (in=a, in=b, out=aANDb); 
                            : NOT (in=aANDb, out=NOTaANDb); 
                            : OR (in=a, in=b, out=aORb); 
                            : AND (in=NOTaANDb, in=aORb, out=out);
                        : AND (in=a, in=b, out=abCARRY)	
                            : >XOR (in=abSUM, in=c, out=abcSUM)
                            : >AND (in=abSUM, in=c, out=abcCARRY)
                                ; >OR (in=abCARRY, in=abcBARRY, out=out)
                        : Flags of Bits: Overflow(>), Zero(=), Negative(<)...    
                    : Logic: Mux/DMux >>> Xor >>> Or >>> And/Nand >>> Not
        : ControlWire: Transistor>IntegratedCircuit>PrintedCircuitBoards>Semiconductor 

~SOFTWARE: OPERATING SYSTEM: Automation/Learning, Optimization/Multi-Tasking, Device Driver
    : LAYERS OF THE OPEN SYSTEM INTERCONNECTION (OSI) MODEL: 
        : 1. Physical Layer:
            Transistors convert digital signals (0s and 1s) into electrical, light, or radio waves
            These signals represent raw binary data
            Electrical pulses are transmitted through various media like copper wires, fiber optic cables, or wireless signals
        : 2. Data Link Layer: The frames are reassembled and validated for any transmission errors.
            Organizes raw bits into frames
            Adds error detection and correction mechanisms
            Manages how devices on the same network communicate
            Transistor-based circuits ensure accurate signal interpretation
        : 3. Network Layer: 
            The packets are reassembled, and IP addresses are used to confirm the data arrived at the correct destination.
            Handles routing of data packets between different networks
            Uses IP addresses to determine destination
            Breaks large data into smaller, manageable packets
            Transistor-based routers and switches make routing decisions
            : Internet Protocol (IP) Header: InternetServiceProvider(ISP)>Wide>LocalAreaNetwork>MAC Address
        : 4. Transport Layer: Segments are reassembled, and any lost data is retransmitted.
            Ensures reliable data transfer
            Manages data segmentation and reassembly
            Provides error checking and flow control
            TCP/UDP protocols govern how data is packaged and transmitted
            : Transmission Control Protocol (TCP): Sequence Switching/Routing Packets, Acknowledging
                : TCP Header: Software Port + Checksum
            : Data Payload (UDP): 
                : Data 
        : 5. Application Layer: 
            The data is handed off to the application that requested it, such as a web browser displaying a webpage.
            Interfaces with user applications
            Protocols like HTTP, FTP define how applications communicate
            Translates user requests into network commands 
            : Domain Name System (DNS) + Web-Server Address
            : Web-Browser/Search Engine: Hypertext Transfer Protocol (HTTP)
                : Web-Address/Page: Universal Resource Locator (URL) + Hyperlinks
                : Hypertext Markup Language (HTML) + CSS
                : Index: Frequency of Words + Backlinks
    : MACHINE-CODE = OPERATION CODE (OPCODE): INSTRUCTION + MEMORY ADDRESS:
        : Memory Size/Length: (4/8(byte)/16(word)/32/64/128)
        : Memory Bit: BinaryStates: 0, 1 (Base-2 Notation)
    : INSTRUCTION/ALGORITHM: Function>Algorithm/Sort>Compression: 
        : LOAD + MEMORY ADDRESS
            : Read (Enable) DATA in MEMORY ADDRESS (RAM)
            : Write (Enable) DATA in Temporary Memory Register
        : ADD/SUBTRACT + MEMORY ADDRESS(ES)
        : STORE
            : Write (Enable) DATA in MEMORY ADDRESS 
            : Read (Enable) DATA in Temporary Memory Register
        : JUMP / JUMP-NEGATIVE + MEMORY ADDRESS
        : HALT   
        : Brute Force, Selection, Merge, Dijkstra... 
        : ControlFlow: Conditional Statement: If/While/For... function(input1, 2)
            : Triggers: Automatically executes actions in response to table events. To enforce rules and maintain data integrity.
            : Conditionals: Enables decision-making in code. To perform actions based on conditions.
                : If/Else If/Else: Executes code based on logical conditions. To handle multiple outcomes.
                : Switch: Simplifies multi-condition branching. To streamline complex conditional logic.
                : Exception Handling: Manages runtime errors. To handle errors gracefully and ensure program stability.
            : Loops: Repeats code execution based on conditions. To perform repetitive tasks.
                : While: Repeats while a condition is true. To handle indefinite iteration.
                : Do-While: Executes at least once before checking conditions. To ensure at least one iteration.
                : For: Iterates a specific number of times. To handle definite iteration.
                : Continue Statement: Skips to the next iteration. To bypass unnecessary code in specific cases.
                : Break Statement: Exits a loop or switch statement early. To terminate iterations based on conditions.	
        : Execute: Return Statement: Then/Else/Next... 
            : Return: Exits a function and optionally returns a value. To end execution and provide a result.
        : Console Input/Output: Reads from and writes to the console. To interact with the user.
        : Search/Queries: a sequence of actions that leads from initial state to a goal state
            : Data Querying: Retrieves specific data from the database. To access and analyze stored information.
            : Sub-Query: Uses the result of one query within another query. To filter or derive conditions dynamically.
            : GROUP BY/HAVING: Groups data and filters results based on aggregate conditions. To summarize and analyze grouped data.
            : Joins: Combines rows from multiple tables. To retrieve related data from different tables.
            : Unions: Merges result sets of multiple SELECT queries. To consolidate data into one result set.
        : Initialization: Assignment Statement: A = 1
            : Import/Include: Brings in external libraries or namespaces. To use classes and methods from other libraries.
            : Declarations: Allocates memory space for storing data. To store data that can be used and manipulated in a program.
            : Assignments: Initializes or updates the value of a variable. To give variables usable values.
            : Comparison: Less Than, Greater Than, Equal
        : List: Queue/Stack, Create-Read-Update-Delete, Normalize
            : String and Date Functions: Manipulates string and date values. To format and extract meaningful information.
            : Data Insertion: Adds new records to a table. To populate the database.
            : Data Update: Modifies existing records in a table. To correct or update information.
            : Data Deletion: Removes records from a table. To delete obsolete or incorrect data.
        : Arithmetic: XOR+ANDCarry/Half, Full, Multi-bit Adder
            : Aggregate Functions: Performs calculations like sum, average, and count. To derive summary statistics.
        : Logic: NOT, AND, OR
    : MEMORY/DATA-STRUCTURE: Read-Write, Management/Data Structure: Allocation/Virtualization, Protection, De+Fragmentation
        : Read-Only Memory (ROM) & Access Control: Defines visibility and accessibility of members. To enforce encapsulation and protect data.
        : Class Definitions: Encapsulates data and behavior in a blueprint for objects. To create reusable structures for organizing data and logic.
            : Functions: Encapsulates reusable blocks of code. To simplify and modularize tasks.
        : Transactions: Groups operations as a single unit of work. To ensure data consistency and integrity.
            : Views: Creates virtual tables based on SQL queries. To simplify complex queries and enhance security.
            : Stored Procedures: Encapsulates SQL statements for reuse. To standardize and simplify repetitive tasks.
        : Database Creation: Creates a new database. To systematically organize and store application data.
            : Table Creation: Defines a structured format for storing data in rows and columns. To organize data with specific attributes.
        : File System: Directory = Name, Type, Root>Sub, Hierarchical/Flat, Metadata: Length, 
            : FILE TYPES: Array, Libraries, Node/Tree, Graph/Web/Forest, 3D Matrix: A fixed-size collection of items of the same type stored in contiguous memory. To efficiently store and access multiple values in a single variable.
                : Wave/Audio: Amplitude, Spectogram
                : Bitmap: GraphicsGenerator>ScreenBuffer(ImageWidthxHeight)
                : Character/Text/List/String = ASCII>UNICODE
                : Number/Integer/Float= 
                    : Scientific Notation; Negative Bit= 2^N-x
                    : Null Value			
        : Pointer: Next Address Reference
            : Primary Key Constraint: Ensures unique identification for each table record. To prevent duplicate records and establish a reliable reference point.
            : Foreign Key Constraint: Links two tables to maintain referential integrity. To model relationships between tables.
        : Indexes(References): Improves the speed of data retrieval. To optimize query performance.

~AUTHORIZATION/SECURITY: Session: The session is maintained or closed as necessary.
    : DIVIDE/UNCERTAINTY: Random variable 
        : NOT-IN-NOT-OUT:
            Hide	| Block
            Mute	| Deafen
            Pause	| Detach
            Choke	| Mask
            Break	| Fast
        : Error/Flags     
            Collision/Network Congestion= conflict with transfer in carrier
                Routine Problem, Hop Limit
                Scrambled Packets
                Growing Wait-Time
            Kernel Panic/Crash, Overflow= not enough memory bit 
            Dirty Bit= Mismatch between Cache and RAM, Bugs, Worm, Malware 
        : Cybersecurity:
            : Threat Model, 
                : Attack vector
                : Brute Force Attack
            : Questions: 
                : Who are you?
                : What should you have access to?
                : What you have?
                : What you are?
            : Authentication
                : Passwords
                : 2/Multi-Factor
            : Premission:
                : Read = Allows a user to see the contents of a file
                : Write = Allows a user to modify the contents
                : Execute = Allows user to run a file
            : Malware:
                : 
            : Security Kernel =
                : Independent Verification & Validation
            : Isolation/Sandbox
            : Virtual Machine
        : Hackers: 
            : White Hats
            : Black Hats
            : Social Engineering
                : Phishing
                : Pre-texting
            : NAND Mirroring 
            : Malware:
                : Trojan Horse
            : Bug Exploits:
                : Buffer Overflow
                : Bounds Checking
                : Canaries
                : Code Injections
            : Zero Day Vulnerability
            : Security Patches 
            : DDos Attacks
        : Cryptography: Defense
            : Encription 
                : Symmetric
                : Asymmetric
                    : Public
                    : Private
            : Decryption
            : Ceasar Cipher
            : Cryptoanalyst
            : Subsctitution Cipher
            : Columnar Transposition Cipher
                : Enigma Rotor
                : The Bombe
            : Data Encryption Standard
                : Advanced Encryption Standard
            : Key Exchange
                : Diffie-Hellman
            : Modular Exponentiation
        
    ~ENGINEERING/COLLABORATION:
        : DEVELOPMENT LIFECYCLE:
            : Planning + Design: Survey-Prove Investors
            : Prototyping (Testing) Development: FAIL FAST!
            : Deployment: Proven Product
            : Maintenance/Warranty
        : Source Control
            : Quality Assurance
            ; Roll Back
        : Repository:
            : Check in vs out
            : Committing

SYSTEMS ANALYSIS & DESIGN
What: Systems Analysis and Design (SAD) is a systematic approach used to develop information systems efficiently. It focuses on understanding business needs, designing solutions, and implementing systems that meet those needs.
Who:
    Systems Analysts
    Developers
    Project Managers
    Business Stakeholders
    End Users
Where: Organizations requiring new or updated systems to manage operations, improve productivity, or address problems in workflows.
When: During the initiation and development of IT systems or digital media solutions.
    Typically starts when a business identifies a need for an improved system or process.
Why (For What):
    To ensure that information systems meet business requirements.
    To create systems that improve efficiency, solve problems, and provide value to users.
    To avoid system failures and inefficiencies.
How (By What Logical Steps):
    Plan: Define the scope, prioritize needs, and plan for system development.
    Analyze: Examine current systems and problems, gather requirements, and develop logical models.
    Design: Create detailed technical specifications for the new system.
    Implement: Build, test, and deploy the system while training users.
    Support: Maintain and refine the system to extend its useful life.

SYSTEM DEVELOPMENT LIFE CYCLE (SDLC)
What: A structured process used for planning, creating, testing, and deploying an information system. The SDLC ensures quality and efficiency in system development.
Who:
    Systems Analysts
    Developers
    Business Analysts
    IT Teams
    End Users
Where: In any organization developing or upgrading information systems.
When: From the inception of a system idea to its retirement.
Why (For What):
    To create systems that align with business goals.
    To deliver projects on time, within budget, and meeting requirements.
How (By What Logical Steps):
    System Planning:
        Identify and prioritize system needs.
        Define the scope and boundaries of the problem.
    System Analysis:
        Build a logical model.
        Analyze current problems and their root causes.
        Define and document business requirements.
    System Design:
        Design solutions (physical models, user interfaces, controls, and security).
        Produce a technical design document.
    System Implementation:
        Develop and deploy the system.
        Train users and create documentation.
        Plan conversion strategies (e.g., parallel, pilot, phased, or direct cutover).
    System Operation and Support:
        Monitor and maintain the system.
        Refine the system design and address issues.
        Ensure continued functionality throughout its useful life.

SYSTEM DEVELOPMENT TOOLS/TECHNIQUES
    What: Tools and methodologies used to facilitate and optimize system development.
        Modeling (e.g., DFD, ERD, UML)
    What: Graphical representations of systems to visualize processes, data, and interactions.
    Who: Systems Analysts and Developers.
    Where: During analysis and design phases.
    Why: To ensure clarity in understanding and communication.
    How: Create models like:
        Data Flow Diagrams (DFDs)
        Entity-Relationship Diagrams (ERDs)
        Unified Modeling Language (UML) diagrams.
Prototyping
    What: Building early, functional models of the system for testing and feedback.
    Who: Developers and End Users.
    Where: During feasibility and early design stages.
    Why: To test ideas, refine requirements, and reduce risks.
    How:
        Develop prototypes based on requirements.
        Test feasibility and gather feedback.
        Iterate to improve before production.
CASE Tools
    What: Software tools for automating and assisting in system development.
    Who: Systems Analysts and IT Teams.
    Where: During design and implementation phases.
    Why: To improve productivity and consistency in system development.
    How: Use CASE tools to:
        Generate designs automatically.
        Standardize methodologies.
        Enhance collaboration and documentation.
Structured Analysis
    What: A traditional methodology for breaking down system functions into detailed processes.
    Who: Systems Analysts.
    Where: During analysis and design phases.
    Why: To ensure thorough understanding and structured documentation.
    How: Use tools like DFDs and process models to detail workflows.
Object-Oriented Analysis
    What: A methodology that focuses on defining systems in terms of objects and their interactions.
    Who: Systems Analysts and Developers.
    Where: In software and systems requiring modularity and reusability.
    Why: To simplify design and enhance flexibility.
    How: Define objects, their properties, behaviors, and relationships.
Joint Application Development (JAD)
    What: Collaborative workshops for stakeholders to define requirements and design solutions.
    Who: Business Stakeholders, Analysts, Developers, and Facilitators.
    Where: During the analysis and design phases.
    Why: To ensure alignment between business needs and technical solutions.
    How: Conduct structured sessions with stakeholders to gather input and refine requirements.

SYSTEMS ANALYSIS & DESIGN: Digital Media and IT Information Technology
    What: The use of systems analysis and design in the field of IT and digital media to solve business problems, manage data, and streamline processes through effective modeling, system development, and user-centric approaches.
    Why Do We Model?
    What: Modeling involves creating structured representations of a system to understand, analyze, and solve problems effectively.
    Who:
        Systems Analysts
        IT Developers
        Project Managers

    Where: During system planning and design phases, typically in organizations using IT systems.
    When: Whenever a problem needs to be solved, alternatives need to be explored, or complexity needs to be managed.
    Why (For What):
        To provide structure to problem-solving.
        To explore multiple solutions efficiently.
        To abstract and simplify complex systems.
        To reduce development time and costs.
        To minimize risks and errors.
    How (By What Logical Steps):
        Identify the problem or system to be modeled.
        Define the goals of modeling (e.g., risk reduction, clarity).
        Create and test models using diagrams, simulations, or prototypes.
        Refine models based on feedback and iterations.

INFORMATION SYSTEMS COMPONENTS
    What: Core components that make up an information system (IS), including data, hardware, and software.
    Who:
        IT Teams
        Business Stakeholders
    Where: In any system designed to process, manage, and use data for operations.
    When: During the design and implementation phases of system development.
    Why (For What):
        To enable efficient data input, processing, and output.
        To support mission-critical operations vital to businesses.
    How:
        Define the system’s purpose and scope.
        Identify and integrate hardware components (physical systems).
        Develop and implement software (programs controlling the hardware).
        Collect and process input data to achieve specific results.

BUSINESS USE OF INFORMATION TECHNOLOGY
What:

How IT is used to support different business operations and decision-making processes.
1. Enterprise Computing Systems
    What: Systems that support company-wide operations and strategic decision-making (e.g., ERP systems).
    Who: Used by top and middle management for strategic planning and operational oversight.
    Where: Large organizations requiring integration across departments.
    When: When streamlining operations and improving efficiency.
    Why: To enhance productivity, reduce costs, and support decision-making.
    How:
        Implement structured rules for predictable tasks.
        Use ERP to consolidate operations into a single system.
        Ensure scalability for future growth.

2. Transaction Processing Systems (TPS)
    What: Applications that handle daily operations like orders, reservations, and payroll.
    Who: Clerical users and operational employees.
    Where: At the transactional level of businesses.
    When: In day-to-day operations requiring real-time data processing.
    Why: To automate repetitive tasks, improve accuracy, and maintain data integrity.
    How:
        Collect input data for transactions.
        Process data in real-time or batch mode.
        Produce outputs for operations (e.g., receipts, records).

3. Business Support Systems (MIS)
What: Systems for generating management reports to aid decision-making.
Who: Middle management.
Where: In organizations requiring structured reporting.
When: During performance evaluations or resource allocation.
Why: To provide insights and summaries of operations.
How:
    Collect data from TPS or other sources.
    Generate detailed, summary, or exception reports.
    Use reports for analysis and decision-making.

4. Decision Support Systems (DSS)
    What: Tools for performing “what-if” analyses and making decisions.
    Who: Middle and top management.
    Where: In scenarios requiring analytical insights.
    When: During planning, budgeting, or forecasting.
    Why: To evaluate alternatives and improve decision-making.
    How:
        Analyze data using simulations.
        Present insights with interactive dashboards.
        Test multiple scenarios to identify optimal solutions.

5. Knowledge Management Systems (KMS)
    What: Advanced systems using expert knowledge to simulate reasoning and provide solutions.
    Who: Used by expert professionals or management.
    Where: In organizations requiring specialized decision-making.
    When: In complex problem-solving scenarios.
    Why: To leverage expertise, manage knowledge, and ensure consistent decisions.
    How:
        Build a knowledge base with encoded rules.
        Use fuzzy logic to manage imprecise relationships.
        Apply inference rules for decision-making.

INFORMATION TECHNOLOGY USERS
1. Top Managers
    What: Users responsible for long-term strategic planning and resource allocation.
    Who: CEOs, directors, and executives.
    Where: At the highest level of management.
    When: During strategic planning and evaluations.
    Why: To set organizational direction and evaluate progress.
    How:
        Use data from enterprise systems.
        Monitor trends and forecast growth.
        Allocate resources effectively.
2. Middle Managers & Knowledge Workers
    What: Users managing teams and performing specialized tasks.
    Who: Department heads, engineers, accountants, HR professionals, etc.
    Where: Mid-level in organizations.
    When: During project management or complex problem-solving.
    Why: To provide direction, support, and performance feedback.
    How:
        Use MIS and DSS for insights.
        Plan resources and delegate tasks.
        Perform analysis and generate reports.
3. Supervisors and Team Leaders
    What: Frontline managers controlling daily operations.
    Who: Office managers, project managers, foremen.
    Where: At the operational level.
    When: During routine business processes.
    Why: To ensure smooth day-to-day functioning.
    How:
        Oversee staff and operations.
        Provide immediate feedback.
        Use TPS for monitoring workflows.
4. Operational Employees
    What: Users directly interacting with systems to perform tasks.
    Who: Clerical workers, data entry staff, sales representatives.
    Where: At the transactional level.
    When: During real-time operations requiring system input/output.
    Why: To execute specific tasks as part of business workflows.
    How:
        Enter data into TPS.
        Process tasks (e.g., reservations, orders).
        Rely on automated systems for efficiency.

Functional Requirements
    What: Functional requirements define what the system is supposed to do. They describe specific behaviors, actions, or tasks the system must perform, focusing on inputs, processing, and outputs.
    Who:
        Stakeholders: Business Analysts, System Analysts, Developers, Testers, End Users
        Users: Those interacting directly with the system (e.g., employees, customers)
    Where:
        In the requirements gathering phase of software or system development.
        Applied to system features, workflows, and business operations.
    When:
        At the initial stages of system analysis and design, during planning and requirements documentation.
        Throughout the development process to ensure the system’s intended behavior is met.
    Why (For What):
        To ensure the system meets its intended purpose and fulfills the user’s needs.
        To define what features and behaviors the system must include for proper operation.
    How (By What Logical Steps):
        Identify the core objectives and purpose of the system.
        Gather input from stakeholders and users regarding what tasks the system must perform.
        Document specific system actions and interactions, such as:
            Business rules.
            Authentication and authorization processes.
            Transaction processing (corrections, adjustments, cancellations).
            Audit tracking and external interfaces.
        Test functionality to verify the system performs as defined.
    Examples:
        A banking system must allow users to transfer funds (Transaction Processing).
        A website requires users to log in with a username and password (Authentication).
        A system must record and store data changes for future reference (Audit Tracking).

Non-Functional Requirements
    What: Non-functional requirements specify how the system performs its tasks. They focus on qualities such as performance, reliability, usability, and scalability rather than specific behaviors.
    Who:
        Stakeholders: Project Managers, System Architects, Quality Assurance Teams, Developers
        Users: Indirectly affect end users who benefit from system quality and reliability.
    Where:
        In technical design documents, architectural planning, and system testing.
        Relevant to system-wide operations and infrastructure.
    When:
        During system design and throughout the development lifecycle to ensure quality attributes are integrated.
        During testing phases to validate compliance with non-functional requirements.
    Why (For What):
        To ensure the system operates efficiently, securely, and reliably under various conditions.
        To improve user experience and ensure compliance with regulatory and operational standards.
    How (By What Logical Steps):
        Define quality standards and expectations for the system.
        Identify specific non-functional requirements, such as:
            Performance (response times, system throughput).
            Scalability (ability to handle growth in users or data).
            Security (data protection, access control).
            Usability (ease of use for end users).
        Develop and implement system architecture to meet these requirements.
        Test the system to verify non-functional attributes under various scenarios (e.g., load testing, recovery testing).
    Examples:
        The system should handle 10,000 simultaneous users (Scalability).
        Data recovery must occur within 2 hours after a system crash (Recoverability).
        The system should respond to user requests within 2 seconds (Performance).

Comparison: Functional vs. Non-Functional Requirements
    Aspect	Functional Requirements	Non-Functional Requirements
    What it defines	What the system does.	How the system performs its tasks.
    Focus	Features and user requirements.	System quality and operational attributes.
    Examples	Transaction processing, authentication, audit tracking.	Performance, scalability, reliability, usability.
    Impact	System won’t function if unmet.	System still functions, but quality may be compromised.
    Testing	Validate features and tasks.	Validate performance and reliability under different conditions.
    Conclusion:
    Why Both Are Important:
        Functional Requirements ensure the system performs its intended tasks.
        Non-Functional Requirements ensure the system performs efficiently, securely, and reliably, improving user satisfaction and long-term operational success.
    How to Address Both:
        Document functional requirements first to define system behavior.
        Develop non-functional requirements to establish quality standards.
        Use iterative testing to ensure compliance with both types of requirements.

Business Rules
    What: A business rule is a statement that defines or influences how a business operates. It governs decisions, processes, and behavior within an organization. Business rules:
        Ensure consistency in decision-making.
        Help automate processes in information systems.
        Provide clear guidelines for employees and systems.
    Who:
        Creators: Business stakeholders, decision-makers, or subject-matter experts with authority (e.g., managers, executives).
        Enforcers: Employees, supervisors, or automated systems.
        Users: Employees or customers interacting with the system or process.
    Where:
        Embedded within operational processes, policies, or automated systems.
        Applicable in industries such as retail, hospitality, logistics, and financial services.
    When:
        During the design and implementation of processes or systems.
        When changes occur in business operations, policies, or objectives.
        In real-time operational scenarios (e.g., checking age for alcohol sales).
    Why (For What):
        To maintain consistent operations and decision-making.
        To enforce organizational policies and legal requirements.
        To automate processes and reduce reliance on human judgment.
        To create new knowledge by systematically applying rules to existing data.
    How (By What Logical Steps):
        Define the behavior or decision the rule governs.
        Observe and document implicit and explicit rules (some may not be written).
        Integrate these rules into business processes or systems.
        Ensure the rule is clear, justified, and enforceable.
        Test the rule in real-world scenarios to ensure it works as intended.
    How Does That Work?
        Example: Hotel Reservation Rule
        What: A customer cannot check in without a reservation.
        Who: Hotel clerks enforce the rule, and the hotel’s booking system supports it.
        Where: At the hotel’s front desk during check-in.
        When: When a customer arrives to check in without prior reservation.
        Why (For What): To ensure efficient room allocation and avoid overbooking.
        How:
            The clerk asks if the customer has a reservation.
            If not, the clerk creates a reservation in the system.
            The customer is then checked in, satisfying the business rule.

Properties of a Good Business Rule
    What: A good business rule should meet specific criteria to ensure clarity, enforceability, and alignment with business objectives.
    Who:
        Authors: Business analysts, subject-matter experts, and managers.
        Reviewers: Quality assurance teams or stakeholders.
    Where: In business policies, training manuals, and automated systems.
    When: When designing, revising, or implementing processes or systems.
    Why (For What): To ensure rules are actionable, clear, and relevant to organizational goals.
    How (By What Logical Steps):
        Atomic: Ensure the rule focuses on a single concept or action.
            Example: "We only ship complete orders."
        Declarative: Specify when and how the rule applies.
            Example: "Before a work order can be completed, a customer’s information must be collected."
        Precise: Avoid ambiguity or multiple interpretations.
            Example: "Any customer that owes more than $5,000 cannot place new orders."
        Justified: Confirm the rule supports business objectives.
        Authorized: Ensure the rule is created by someone with decision-making authority.

Business Rule Examples
    What: Practical examples that demonstrate how business rules guide actions and processes.
    Examples:
        Everyone under the age of 25 must have their ID checked (compliance rule).
        Orders are only shipped when complete (operational rule).
        Customers with debts over $5,000 cannot place new orders (financial rule).
        Vehicles must be visually inspected for damage before release (safety rule).
    Who:
        Employees (e.g., clerks, warehouse staff, inspectors) execute these rules.
        Systems enforce or automate the rules.
    Where: Retail counters, warehouses, customer service desks, etc.
    When: During specific processes such as checkout, shipping, or quality assurance.
    Why (For What): To ensure compliance, efficiency, safety, and financial prudence.
    How:
        Define the rule clearly.
        Train staff and configure systems to enforce the rule.
        Monitor adherence and adjust as needed.

Five Steps for Creating a Business Rule Collection
    What: A structured approach to defining and managing a set of business rules.
    Who:
        Collectors: Business analysts, process owners, or system architects.
        Validators: Stakeholders ensuring rules align with objectives.
    Where: In requirements documents, project plans, or system design specifications.
    When: At the beginning of a project or when revising processes.
    Why (For What): To systematically document and organize rules for clarity, relevance, and enforceability.
    How (By What Logical Steps):
        Collect business ramblings: Gather informal or implicit rules by observing operations and interviewing stakeholders.
        Translate these ramblings into business rules: Reword them into clear, structured statements.
            Example: "Orders must be shipped complete."
        Determine which rules are relevant to project objectives: Filter out irrelevant or outdated rules.
        Determine data-rule dependencies: Identify which data elements the rules depend on (e.g., customer age, reservation status).
        Determine inter-rule relationships: Map how rules interact or overlap to avoid conflicts.

What is Risk?
    What: Risk refers to the potential positive or negative effects of an event or series of events on a project. It encompasses uncertainty and its impact on project outcomes.
    Who:
        Stakeholders: Project Managers, Risk Managers, Team Members, Business Stakeholders.
        Affected Parties: The organization, clients, or customers relying on the project’s success.
    Where: In all phases of a project, primarily during the Planning Phase but monitored throughout execution.
    When: At the start of the project (to identify risks early) and continually during the project lifecycle as risks evolve.
    Why (For What):
        To anticipate potential problems and avoid or minimize their effects.
        To take advantage of positive risks (opportunities) when they occur.
    How (By What Logical Steps):
        Define risks that could affect the project.
        Categorize risks as opportunities or threats.
        Assess their likelihood and potential impact.
        Develop mitigation and contingency strategies.
        Monitor risks throughout the project lifecycle.

Risk Affects Project Planning
    What: Risk management is an integral part of project planning to prevent small issues from escalating into emergencies.
    Who:
        Planners: Project Managers, Risk Analysts.
        Executors: Team Members and Stakeholders responsible for implementing risk responses.
    Where:
        During the Planning Phase but continues to evolve through project execution.
    When:
        Before starting the project and as part of periodic reviews throughout the project.
    Why (For What):
        To ensure smooth project execution.
        To avoid budget overruns, missed deadlines, or project failure.
        To build proactive strategies for unforeseen challenges.
    How:
        Include risk analysis as part of the project planning process.
        Continuously update the risk register as new risks are identified.
        Regularly evaluate risks to keep the project on track.

Components of Risk
    What: Risk is composed of five key elements:
        Event: What could happen?
        Probability: How likely is the event to happen?
        Impact: How bad will it be if it happens?
        Mitigation: How can the probability be reduced?
        Contingency: How can the impact be reduced if it does happen?
    Who:
        Assessors: Project Managers, Risk Analysts.
        Implementers: Team Members responsible for mitigation and contingency measures.
    Where: In the risk register or risk log, which tracks and monitors these components.
    When: During risk identification and analysis, and as part of ongoing project monitoring.
    Why (For What):
        To create structured strategies for managing risks.
        To minimize the impact of negative events and maximize the potential of positive ones.
    How:
        Identify potential risks (events) in the project.
        Assign a probability (High, Medium, Low) to each event.
        Assess the impact of each event on the project.
        Develop mitigation strategies to lower the likelihood of occurrence.
        Develop contingency plans to reduce the impact if the event occurs.

Creating a Risk List
    What: A risk list is a prioritized collection of potential project risks, detailing their probability, impact, and mitigation/contingency plans.
    Who: Created by Project Managers, Risk Analysts, and Team Members.
    Where: Documented in the project risk register or risk management plan.
    When: During the project’s planning phase and continuously updated throughout.
    Why (For What):
        To organize and prioritize risks for proactive management.
        To provide clarity on which risks to address first.
    How:
        Describe the risk event briefly (1–2 sentences).
        Assign a probability (High, Medium, Low) to each risk.
        Develop mitigation strategies to reduce the likelihood of high/medium probability risks.
        Assess the impact (High, Medium, Low) of each risk.
        Develop contingency plans to address the impact if the risk materializes.

Assessing Probability and Impact
    What:
        Probability: The likelihood of a risk occurring.
        Impact: The severity of the risk's effect on the project.
    Who: Project Managers and Risk Analysts assess these factors.
    Where: Recorded in the project’s risk analysis documentation.
    When: During the risk identification and analysis phases.
    Why (For What):
        To determine which risks to prioritize and address.
        To allocate resources effectively for risk management.
    How:
        Use a High, Medium, Low scale to categorize probability and impact.
        Address high-probability and high-impact risks first.
        Continuously re-evaluate risks as the project progresses.

Example of a Risk Event
    What: Event: Critical parts needed for the project do not arrive on time.
    Who:
        Mitigation: Team responsible for procurement orders parts early.
        Contingency: Team uses old parts temporarily until new parts arrive.
    Where: In the supply chain and project schedule.
    When: Identified during planning and monitored during execution.
    Why (For What): To avoid delays and ensure the project stays on schedule.
    How:
        Identify the risk event (parts delay).
        Assign Medium probability and High impact.
        Mitigate by ordering parts early in the project.
        Create a contingency plan to use existing parts temporarily.

Five Steps for Risk Management
    What: A structured process for identifying, analyzing, and managing risks.
    Who: Project Managers, Risk Analysts, Team Members.
    Where: Within the project’s risk management plan.
    When: Throughout the project lifecycle.
    Why (For What): To proactively manage risks and improve project success.
    How (By What Logical Steps):
        Collect business ramblings: Brainstorm potential risks with the team.
        Translate ramblings into risks: Reframe vague concerns into clear, actionable risk statements.
        Determine relevant risks: Filter out unlikely or irrelevant risks.
        Determine data-rule dependencies: Identify what data or processes are tied to each risk.
        Determine inter-rule relationships: Analyze how risks may interact or compound.

Feasibility
    What: Feasibility refers to assessing whether a proposed project is practical, achievable, and worthwhile to pursue. A feasibility study evaluates the potential success of a project across multiple dimensions.
    Who:
        Conducted by: Systems Analysts, Business Analysts, Project Managers.
        Stakeholders: Decision-makers, IT teams, financial teams, and end users.
    Where: Applied during the planning phase of a project or system development.
    When:
        Before initiating a project to ensure it is viable.
        At critical decision points during the project lifecycle.
    Why (For What):
        To determine if a project is worth pursuing in terms of cost, resources, and time.
        To identify risks, constraints, and benefits of the proposed project.
    How (By What Logical Steps):
        Define the project scope and objectives.
        Identify and evaluate feasibility criteria (operational, technical, economic, schedule).
        Collect data through interviews, surveys, and research.
        Analyze the data and prepare a feasibility report.
        Make a recommendation based on the findings.

What is a Feasibility Study?
    What: A feasibility study is an ongoing process of tests to evaluate if a project is desirable, practical, and achievable. It ensures a project meets the following criteria:
        Operational feasibility.
        Technical feasibility.
        Economic feasibility.
        Schedule feasibility.
    Who:
        Conducted by analysts and project managers.
        Used by stakeholders for decision-making.
    Where: In project proposals and system development processes.
    When: Before project initiation and during project evaluations.
    Why (For What):
        To prioritize projects based on their potential for success and alignment with business goals.
        To avoid pursuing projects that are not viable.
    How:
        Define the problem or opportunity.
        Assess the project against each feasibility dimension.
        Prepare and present a feasibility report to stakeholders.

Operational Feasibility
    What: Operational feasibility evaluates whether the proposed system will be used effectively once implemented.
    Who:
        Management and users who will interact with the system.
        Analysts assessing operational requirements and impacts.
    Where: In the organization’s day-to-day operations and workflows.
    When: During the project planning and design phases.
    Why (For What):
        To ensure user adoption and effective use of the system.
        To identify and mitigate risks such as workforce resistance or legal/ethical concerns.
    How:
        Evaluate if management supports the project.
        Assess workforce impacts (e.g., training, reductions).
        Determine user involvement in planning and implementation.
        Identify potential customer effects and risks to company image.
        Check for conflicts with other organizational priorities.

Technical Feasibility
    What: Technical feasibility examines the availability and adequacy of technical resources (hardware, software, expertise) to support the proposed system.
    Who: IT teams, systems architects, and technical analysts.
    Where: Within the organization’s technical infrastructure.
    When: During the planning and early stages of system development.
    Why (For What):
        To determine if the organization has the necessary resources and expertise to implement the system.
        To ensure the system can handle future needs and growth.
    How:
        Assess the availability of required hardware and software.
        Determine if the company has the technical expertise for development and maintenance.
        Evaluate platform capacity for scalability and reliability.
        Test the system's ability to handle expected transaction volumes.

Economic Feasibility
    What: Economic feasibility determines if the projected benefits of the system outweigh its estimated costs, considering total cost of ownership (TCO) and return on investment (ROI).
    Who: Financial analysts, project managers, and stakeholders.
    Where: In cost-benefit analysis and financial evaluations of the project.
    When: During the feasibility study phase and before resource allocation.
    Why (For What):
        To ensure the project is financially viable.
        To determine if the investment will "pay off."
    How:
        Identify all costs, including development, maintenance, training, hardware, and licensing.
        Calculate ROI:
        ROI = (Net Profit / Total Costs) × 100
        Example: If net profit is $20,000 and total costs are $10,000:
        ROI = (20,000 / 10,000) × 100 = 200%.
        Compare costs to projected benefits (financial and operational).

Schedule Feasibility
    What: Schedule feasibility evaluates whether the project can be completed within an acceptable or established time frame.
    Who: Project managers and stakeholders.
    Where: In project timelines and schedules.
    When: During the planning phase and when setting deadlines.
    Why (For What):
        To ensure the project can meet deadlines without sacrificing quality.
        To identify risks associated with tight schedules.
    How:
        Determine if management has set a firm deadline.
        Assess risks associated with an accelerated schedule.
        Appoint a project manager to oversee timelines.
        Create a detailed project schedule with milestones and deadlines.

###########################################################################################################
: NOTES: ARTIFICIAL INTELLIGENCE NOTES
: SEARCH
    : Uninformed: 
        : Depth-First (Stack)
            : Start with a frontier that contains the intitial state.
            : Start with an empty explored set.
            : Repeat:
                : If the frontier is empty, then no solution.
                : Remove a node from the frontier.
                : If node contains goal state, return the solution.
                : Add the node to the explored set.
                : Expand node, add resulting nodes to the frontier, if they are NOT already in the frontier or the explored set.
        : Breadth-First (Queue)
    : Informed: with Heuristic Function
        : Greedy Best-First
        : A*: g(n) + h(n)
            : g(n) = cost to reach node
            : h(n) = estimated cost to goal 
            : optimal if:
                : h(n) is admissible (never overestimates the true cost)
                : and h(n) is consistent (for every node n and successor n' with step cost c, h(n) < h(n') + c) 
    : Adversarial: with Adversary
        : Minimax: Win-Lose Goal-State
            : Set Agents:
                : MAX aims to maximize score
                : MIN aim to minimize score
            : Set Outcomes: 
                : -1 = Lose
                : 0 = Tie
                : +1 = Win
            : Given a state s:
                : MAX picks action a in ACTIONS(s) that produces highest value of MIN-VALUE(RESULTS(s, a))
                : MIN picks action a in ACTION(s) that produces smallest value of MAX-VALUE(RESULTS(s, a))
            : Pseudocode:
                function MAX-VALUE(state):
                    if TERMINAL(state):
                        return UTILITY(state)
                    v = -infinity
                    for action in ACTIONS(state):
                        v = MAX(v, MIN-VALUE(RESULT(state, action)))
                    return v
                
                function MIN-VALUE(state):
                    if TERMINAL(state):
                        return UTILITY(state)
                    v = infinity
                    for action in ACTIONS(state):
                        v = MIN(v, MAX-VALUE(RESULT(state, action)))
                    return v
        : Alpha-Beta Pruning
        : Depth-Limited Minimax: with Evaluation function

: LOGIC: 
    : Logical Connectives: 
        : not ¬, 
        : and ∧, 
        : or ∨,
        : implication →
        : biconditional ↔
    : Entailment Algorithm: Does KB ⊨ α ?
    : Model Checking: (logic.py)
        : To determine if KB ⊨ α:
            : Enumerate all possible models.
            : If in every model where KB is true, α is true, then KB entals α.
            : Otherwise, KB does not entail α.
    : Knowledge Engineering:
    : Inference Rules:
        : Modus Ponens: α → β
        : And Elimination: α ⊨ β
        : Double Negation Elimination:
        : Implication Elimination
        : Biconditional Elimination
        : De Morgan's Law
        : Distributive Property/Law
        : Unit Resolution
    : Conversion to conjunctive normal form (CNF)
        : Eliminate biconditionals
        : Eliminate implications
        : Move not inwards using De Morgan's laws
        : Use distributive law to distribute or wherever possible
    : Inference by Resolution
        : To determine if KB ⊨ α:
            : Convert (KB and not alpha) to Conjunctive Normal Form.
            : Keep checking to see if we can use resolution to produce a new clause.
                : If ever we produce the empty clause (equivalent to false), we have a contradiction, and KB ⊨ α.
                : Otherwise, if we cannot add new clauses, no entailment.
    : First-Order Logic
        : Universal Quantificationa
        : Existential Quantification
: PROBABILITY: 
    : Bayes' Rule: P(b | a) = P(a | b) P(b) / P(a)
    : Probability Rules:
        : Negation
        : Inclusion-Exclusion
        : Marginalization
        : Conditioning
    : Inference by Enumeration
    : Approximate Inference:
    : Sampling
        : Rejection Sampling
        : Likelihood Weighting
    : hidden Markov Model: Task:
        : Filtering = given objservations from start until now, calculate distribution for current state
        : prediction = given observations from start until now, calculate distribution for a future state
        : smoothing = given observations from start until now, calculate distribution for past state
        : most likely explanation = given observatinos from start until now, calculate most likely sequence of states
: OPTIMIZATION:
    : Local Search = search algorithms that maintain a single node and searches by moving to a neighboring node
        : Hill Climbing
            : function HILL-CLIMB(problem):
                : current = initial state of problem
                : repeat:
                    neighbor = highest valued neighbor of current
                    if neighbor not better than current:
                        return current
                    current = neighbor
            : steepest-ascene = choose the highest-valued neighbor
            : stochastic = choose randomly from higher-valued neighbors
            : first-choice = choose the first higher-valued neighbor
            : random-restart = conduct hill climbing multiple times
            : local beam search = chooses the k highest-valued neighbors
        : Simulated Annealing =
            function SIMULATED-ANNEALING(problem, max):
                current = initiate state of problem 
                for t = 1 to max:
                    T = TEMPERATURE(t)
                    neighbor = random neighbor of current 
                    deltaE = how much better neigh is than current
                    if deltaE > 0:
                        current = neighbor
                    with probability e^deltaE/T set current = neighbor
                return current
        : Linear Programming:
            : Simplex
            : Interior-Point
        : arc consistency = when all the values in a variable's domain satisfy the variable's binary constraints
            : function REVISE(csp, X, Y):
                revised = false
                for x in X.domain:
                    if no y in Y.domain satisfies constrain for (x, Y):
                        delete x from X.domain
                        revised = true
                    return revised
            : function AC-3(csp)
                queue = all arcs in csp
                while queue non-empty:
                    (X, Y) = DEQUEUE(queue)
                    if REVISE(csp, X, Y):
                        if size of X.domain == 0:
                            return false
                        for each Z in X.neighbors - {Y}:
                            ENQUEUE(queue, (Z, X))
                    return true 
        : Backtracking Search:
            : function BACKTRACKING(assignment, csp):
                if assignment complete: return assignment
                var = SELECT-UNASSIGNED-VAR(assignment, csp)
                for value in DOMAIN-VALUES(var, assignment, csp):
                    if value consistent with assignment:
                        add {var = value} to assignment
                        result = BACKTRACK(assignment, csp)
                        if result not= failure: return result
                    remove {var = value} from assignment
                return failure
        : maintaining arc consistency = algorithm for enforcing arc-consistency every time we make a new assignment 
            : function BACKTRACKING(assignment, csp):
                if assignment complete: return assignment
                var = SELECT-UNASSIGNED-VAR(assignment, csp)
                for value in DOMAIN-VALUES(var, assignment, csp):
                    if value consistent with assignment:
                        add {var = value} to assignment
                        inferences = INFERENCES(assignment, csp)
                        if inferences not= failure: add inferences to assignment
                        result = BACKTRACK(assignment, csp)
                        if result not= failure: return result
                    remove {var = value} and inferences from assignment
                return failure
: LEARNING:
    : supervised learning = given a data set of input-output pairs, learn a function to map inputs to outputs
        : classification = supervised learning task of learning a function mapping an input point to a discrete category
            : nearest-neighbor classification = algorithm that, given an input, chooses the class of the nearest data point to that input
            : k-nearest-neighbor classification = algorithm that, given an input, chooses the most common class out of the k nearest data points to that input
        : hypothesis hw(x) = 1 if w * x > 0; 0 otherwise
        : perceptron learning rule = given data point (x, y), update each weight according to: 
            : wi = wi + a(y - hw(x)) * xi
            : wi = wi + a(actual value - estimate) * xi
            : Only capable of learning linearly separable decision boundary.
        : Support Vector Machine
            : boundary that maximizes the distance between any of the data points 
        : regression = supervised learning task of learning a function mapping an input point to a continuous value
        : regularization = penalizing hypotheses that are more complex to favor simpler, more general hypotheses
        : holdout cross-validation = splitting data into a training set and a test set, such that learning happens on the training set and is evaluated on the test set
        : k-fold cross-validation = splitting data into k sets, and experimenting k times, using each set as a test set once, and using remaining data as training set
    : reinforcement learning = given a set of rewards or punishments, learn what actions to take in the future
        : Q-learning = method for learning a function Q(s,a), estimate of the value of performing action a in state s
            : Start with Q(s,a)=0 for all s,a
            : When we take an action and receive a reward:
                : Estimate the value of Q(s,a) based on current reward and expected future rewards
                : Update Q(s,a) to take into account old estimate as well as our new estimate
        : Greedy Decision-Making
            : When in state s, choose action a with the highest Q(s,a)
        : Explore vs Exploit 
            : Epsilon-Greedy:
                : Set epsilon equal to how often we want to move randomly.
                : With probability 1 - epsilon, choose estimated best move.
                : With probability epsilon, choose random move.
        : function approximation = approximating Q(s,a) often by a function combining various features, rather than storing one value for every state-action pair
    : unsupervised learning = given input data without any additional feedback, learn patterns
        : clustering = organizing a set of objects into groups in such a way that similar objects tend to be in the same group
            : k-means clustering = algorithm for clustering data based on repeatedly assigning points to clusters and updating those clusters' centers
            :  
: NEURAL NETWORKS:
    : Neurons are connected to and receive electrical signals from other neurons.
    : Neurons process input signals and can be activated.
    : artificial neural network = mathematical model for learning inspired by biological neural networks
        : Model mathematical function from inputs to outputs based on the structure and parameteres of the network.
        : Allows for learning the network's parameters based on data.
        : Functions:
            : step function: g(x) = 1 if x > 0, else 0
            : logic sigmoid
            : rectified linear unit (relu)
        : h(x1, x2) = g(w0 + w1x1 + w2x2)
        : h(x1, x2, xn-1, xn) = g(n sigma i=1 xiwi + w0)
    : supervised neural network: 
        : gradient descent = algorithm for minimizing loss when training neural network
            : Start with a random choice of weights.
            : Repeat: 
                : Calculate the gradient based on ALL DATA POINTS: direction that will lead to decreasing loss.
                : Update weights according to the gradient.
        : Stochastic gradient descent
            : Start with a random choice of weights.
            : Repeat: 
                : Calculate the gradient based on ONE DATA POINTS: direction that will lead to decreasing loss.
                : Update weights according to the gradient.
        : Mini-Batch gradient descent
            : Start with a random choice of weights.
            : Repeat: 
                : Calculate the gradient based on ONE SMALL BATCH: direction that will lead to decreasing loss.
                : Update weights according to the gradient.
    : multilayer neural network = artificial neural network with an input layer, an output layer, and at least one hidden layer 
    : backpropagation = algorithm for training neural netowrks with hidden layers
        : Start with a random choice of weights.
        : Repeat:
            : Calculate error for output layer.
            : For each layer, starting with output layer, and moving inwards towards earliest hidden layer:
                : Propagate error back one layer.
                : Update weights.
    : deep neural networks = neural network with multiple hidden layers
    : dropout = temporarily removing units - selected at random - from a neural network to prevent over-reliance on certain units
    : computer vision = computational methods for analyzing and understanding digital images
    : image convolution = applying a kernel/filter that adds each pixel value of an image to its neighbors, weighted according to a kernel matrix
    : pooling = reducing the size of an input by sampling from regions in the input
        : max-pooling = pooling by choosing the maximum value in each region
    : convolutional neural network = neural networks that use convolution, usually for analyzing images
        : Apply convolution
        : Apply pooling
        : Apply Flattening
        : Apply Deep Neural Networks
    : feed-forward neural network = neural network that has connections only in one direction
        : input >>> network >>> output
    : recurrent neural network: input >>> network (loop) >>> output
        : Relationships:
            : one-to-many 
            : many-to-one
            : many-to-many
: NATURAL LANGUAGE PROCESSING:
    : tokenization = the task of splitting a sequence of characters into pieces (tokens)
    : text classification =
    : Naive-Bayes classifier = 
    : additive smoothing = adding a value a to each value in our distribution to smooth the data  
        : Laplace smoothing = adding 1 to each value in ou r distribution: pretending we've seen each value one more time than we actually have
    : Word Representation
    : Question "What is that?" >>> Recurrent Network >>> Answer "This is apple."
    : Encoder >>> Hidden State >>> Decoder
    : Attention = letting us decide which values are important to pay attention to when generating, in this case, the next word in our sequence.
    : Machine Translation 
    : Transformers Architecture
        : Encoder: input word + positional encoding >>> (multi-head self attention >>> neural network) * Number >>> encoded representation
        : Decoder: previous output word + positional encoding >>> (multi-head self attention >>> (encoded representations) attention >>> neural network) * Number >>> encoded representation

######################################################################################################
~ATTENTION IS ALL YOU NEED:
1. Encoder-Decoder Architecture Overview
	Goal: Convert an input sequence into an output sequence (e.g., translating English to German).
	Components:
		Encoder: Processes the input sequence to produce an intermediate representation.
		Decoder: Uses the intermediate representation to generate the output sequence.
2. Input Representation: 
	Input tokens (words) are converted into fixed-size vectors using embedding layers:
		𝑋embed = Embedding(𝑋input)
	Add positional encodings to include order information:
		𝑋 = 𝑋embed +PositionalEncoding
3. Encoder Steps
	Each encoder layer has two sub-layers:
	Multi-Head Self-Attention: Each position in the sequence attends to every other position:
		Attention(𝑄,𝐾,𝑉)=softmax(𝑄𝐾𝑇𝑑𝑘)𝑉
	where:
		𝑄=𝑋𝑊𝑄,𝐾=𝑋𝑊𝐾,𝑉=𝑋𝑊𝑉
		𝑊𝑄,𝑊𝐾,𝑊𝑉 are learned projection matrices.
	Use multiple attention heads (ℎ) to attend to different representation subspaces:
		MultiHead(𝑄,𝐾,𝑉)=Concat(head1,…,headℎ)𝑊𝑂
    MultiHead(Q,K,V)=Concat(head 
    Feed-Forward Network (FFN):
    Applies a pointwise transformation to each position independently:
    Add residual connections and layer normalization:
4. Decoder Steps
    Similar to the encoder, but with an additional attention step:
    Masked Multi-Head Self-Attention:
    Prevents attending to future tokens by masking out invalid positions.
    Encoder-Decoder Attention:
    The decoder attends to the encoder’s output:
    Feed-Forward Network (FFN):
    Same as in the encoder layers.
    Add residual connections and layer normalization after each sub-layer.
5. Output Prediction
    The final decoder output is passed through a linear layer to map it back to the size of the vocabulary.
    Apply a softmax function to get probabilities for each token:
6. Training and Optimization
    Use the Adam optimizer with a custom learning rate schedule:
Summary of Logical Steps
    Embed Input: Represent tokens as vectors and add positional encoding.
    Encode Input: Pass through 
    𝑁
    N-layer encoder using self-attention and feed-forward steps.
    Decode Output: Pass through 
    𝑁
    N-layer decoder using masked self-attention, encoder-decoder attention, and feed-forward layers.
    Generate Prediction: Map decoder outputs to probabilities via softmax.
    Optimize: Train the model using Adam and a dynamic learning rate schedule.
    This structured approach ensures efficient learning and high-quality sequence transduction.

###########################################################################################################
~MEMORY HIERARCHY LEVELS: Focuses on hierarchy by speed and cost efficiency, supporting temporary and volatile storage.
    1. REGISTERS = 
    2. CACHE MEMORY = 
    3. MAIN MEMORY (RAM) = 
    4. SECONDARY STORAGE = 
    5. TERTIARY STORAGE
    6. CLOUD STORAGE

~FILE SYSTEM MEMORY HIERARCHY: Deals with directory structures, access permissions, and long-term storage management.
    1. PHYSICAL STORAGE LAYER
    2. CLOCK STORAGE LAYER
    3. FILE SYSTEMN METADATA LAYER
    4. DIRECTORY TREE STRUCTURE
    5. FILE-LEVEL ABSTRACTION
    6. ACCESS CONTROL AND PERMISSIONS LAYER.
    7. LOGICAL FILE ORGANIZATION (INDEXING/ALLOCATION)
    8. NETWORKING AND DISTRIBUTED FILE SYSTEMS

###############################################################################################################################
~DATABASE FUNDAMENTALS:
    : DATABASE THEORY: Ensures efficient, consistent, and scalable database designs.
        : Business Rules:
        : Databases store data, 
        : Database Managment System is used to manage and interact with the database.
        : Relational DBMS: A type of DBMS that organizes data into tables with rows and columns.
            : Business Rules: Define how tables relate to each other.
            : Entities: Real-world objects (e.g., Customer, Order).
                : Associative: a table used to represent many-to-many relationships between two entities. 
                    It includes the primary keys of both entities as foreign keys and may have additional attributes.
            : Attributes: Properties of entities. They have a domain, which is the set of valid values an attribute can assume 
                : Atomic: cannot be broken down further into meaningful parts (e.g., FirstName).
                : Composite: can be divided into smaller meaningful components (e.g., Address → Street, City, PostalCode).
                : Stored: physically stored in the database (e.g., DateOfBirth).
                : Derived: calculated or derived from other attributes (e.g., Age derived from DateOfBirth). 
                : Non-Key:
        : Keys:
            : Primary: is a unique identifier for each record in a table (e.g., CustomerID). 
            : Technical: is an artificial identifier created by the database designer when no natural unique attribute exists 
            : Composite (or Concatenated): is a primary key that consists of two or more attributes 
            : Foreign: an attribute in one table that references the primary key in another table to establish a relationship 
        : Relationships/Cardinality: Dependencies between entities (e.g., Customer places Order). 
            : Parent-Child: formed when the primary key of the parent table is referenced as a foreign key in the child table 
            : One-to-One (1:1): One instance of an entity is linked to one instance of another entity.
            : One-to-Many (1:N): One instance of an entity is linked to many instances of another entity.
            : Many-to-Many (M:N): Multiple instances of one entity are linked to multiple instances of another entity.
            : Transitive Dependencies: Non-Key: depend only on the primary key
            : Non-Identifying Relationship: 
            : Partial Dependencies
   : Database Design Process: The structured process of creating a database schema that supports application requirements.
        : Implement Foreign Keys: Use foreign keys, which connect the primary key of one entity to a field in another.
        : Handle Many-to-Many Relationships: Break them into two one-to-many relationships by creating an associative entity.
        : Use ERD notations (e.g., IDEF1X) to depict the schema.
            : Entity-Relationship Diagram (ERD): A graphical representation showing entities, attributes, and their relationships.
            : Include relationship labels and cardinality symbols for clarity.
            : Iteratively Refine the Design: Ensure the relationships meet business requirements and minimize data redundancy.
        : Entity-Relationship Diagram (ERD): A graphical representation of entities and their relationships.
            : Entities: Represented as boxes with attributes inside.
            : Attributes:
                : Primary keys are listed above the line in an entity box.
                : Foreign keys are suffixed with "FK."
            : Relationships/ Symbols of Cardinality:
                : Dashed lines for non-identifying relationships.
                : Solid lines for identifying relationships.
     
    : NORMALIZATION: A process for organizing data to reduce redundancy and ensure consistency.
        ~1: Collect views(subsets of data) using source documents and business rules.
        ~2: 
            : Initial Table: Identify Primary Key and repeating group(s) of attributes.
            : First Normal Form (1NF):
                Ensures that all columns contain atomic (indivisible) values.
                Eliminates repeating groups or arrays within a table.
                IMPORTANT: After 1NF, there should be never more than 2 entities/tables.
            : Second Normal Form (2NF):
                Builds on 1NF.
                Ensures all non-key attributes are fully dependent on the primary key.
                    - A violation can only occur in a table with a composite key
                Eliminates partial dependencies (dependencies on part of a composite primary key).
            : Third Normal Form (3NF):
                Builds on 2NF.
                Ensures no non-key attribute is dependent on another non-key attribute (removes transitive dependencies).
            
            : Boyce-Codd Normal Form (BCNF):
                A stricter version of 3NF.
                Ensures every determinant is a candidate key(i.e., no attribute can determine another unless it is part of a candidate key).
            : Fourth Normal Form (4NF):
                Eliminates multi-valued dependencies.
                Ensures that one column's value is not dependent on multiple values of another column.
            : Domain-Key Normal Form (DKNF):
                Theoretical "ultimate" form of normalization.
                Ensures no constraints exist other than key constraints and domain constraints.
                Rarely implemented due to its complexity.
        ~3: Merge

~Inventory View: Inventory
    ItemTypeID
        ItemTypeDescription
    ItemID
        ItemDescription
    Price/Day
    
    : 0NF:
        InventoryTable
        ItemTypeID(PK), ItemTypeDescription, ItemID, ItemDescription, Price/Day
    : 1NF-2NF-3NF: (No Violations)
        InventoryTable
        ItemTypeID(PK), ItemTypeDescription, 
        
        ItemID(PK), ItemTypeID(FK), ItemDescription, Price/Day

~Staff Information View: StaffInformation
    StaffID: 343, 245, 125,
        Name:
            FirstName: Bob, Susie, Jason
            LastName: Jones, Q, Qwerk
        Phone: N, N, N
        Wage: $, $, $
        HireDate: D, D, D,
        +StaffTypeID "Staff members are all of one particular Staff Type."
            StaffType: Producer, Producer, Sales
    
    : 0NF: 
        StaffTable
        StaffID(PK), Name, Phone, Wage, HireDate, StaffType, +StaffTypeID
    : 1NF-2NF (No Change)
        StaffTable
        StaffID(PK), FirstName, LastName, Phone, Wage, HireDate, StaffType, StaffTypeID
    : 3NF: 
        StaffTable
        StaffID(PK), FirstName, LastName, Phone, Wage, HireDate, StaffTypeID(FK)

        StaffTypeTable
        StaffTypeID(PK), StaffType


~Memories Forever: 
    ProjectID
        ProjectDescription
        
        ClientID
            Organization
            Name >>> FirstName, LastName
            Phone
            Email
            Address >>> Street, City, Province
        ProjectInDate
        ProjectDoneDate
        ProjectEstimate
        ProjectTypeCode
        ProjectTypeDescription
        
        ItemID
        Description
        CheckInNotes
        CheckOutNotes
        DateOut
        DateIn

        Price/Day
        Days
        ExtPrice

        StaffID
        StaffName
        Subtotal
        GST
        Total
    
    ~0NF: 
        ProjectID(PK),
            ProjectDescription, 
                ProjectInDate, 
                ProjectDoneDate, 
                ProjectEstimate,
                ProjectTypeCode,
                    ProjectTypeDescription,
                ClientID,
                    Organization,
                    Name >>> FirstName, LastName,
                    Phone,
                    Email,
                    Address >>> Street, City, Province,
                StaffID,
                    StaffName >>> StaffFirstName, StaffFirstName
                Subtotal, GST, Total,
        (ItemID, Description, CheckInNotes, CheckOutNotes, DateOut, DateIn, PricePerDay, Days, ExtPrice, HistoricPricePerDay)
    ~1NF: 
        ProjectTable
        ProjectID(PK),
            ProjectDescription, 
                ProjectInDate, 
                ProjectDoneDate,
                ProjectEstimate,
                ProjectTypeCode,
                    ProjectTypeDescription,
                ClientID,
                    Organization,
                    Name >>> FirstName, LastName,
                    Phone,
                    Email,
                    Address >>> Street, City, Province,
                StaffID,
                    StaffName >>> StaffFirstName, StaffFirstName
                Subtotal, GST, Total,
        
        ItemTable
        ProjectID(FK), ItemID(PK), Description, CheckInNotes, CheckOutNotes, DateOut, DateIn, PricePerDay, Days, ExtPrice, HistoricPricePerDay)
    ~2NF: 
        ProjectTable
        ProjectID(PK),
            ProjectDescription, 
                ProjectInDate, 
                ProjectDoneDate,
                ProjectEstimate,
                ProjectTypeCode,
                    ProjectTypeDescription,
                ClientID,
                    Organization,
                    Name >>> FirstName, LastName,
                    Phone,
                    Email,
                    Address >>> Street, City, Province,
                StaffID,
                    StaffName >>> StaffFirstName, StaffFirstName
                Subtotal, GST, Total,
        
        ItemTable
        ProjectID(FK)(PK), ItemID(FK)(PK), Description, CheckInNotes, CheckOutNotes, DateOut, DateIn, PricePerDay, Days, ExtPrice, HistoricPricePerDay)

        ItemPriceTable
        ItemID(PK), Description, PricePerDay,
    ~3NF: 
        ProjectTable
        ProjectID(PK), ClientID(FK), StaffID(FK), ProjectTypeCode(FK)
            ProjectDescription, 
                ProjectInDate, 
                ProjectDoneDate,
                ProjectEstimate,
                Subtotal, GST, Total,
        
        ProjectTypeTable
        ProjectTypeCode(PK),
            ProjectTypeDescription,
       
        ClientTable
        ClientID(PK),
            Organization,
            Name >>> FirstName, LastName,
            Phone,
            Email,
            Address >>> Street, City, Province,
        
        StaffTable
        StaffID(PK),
            StaffName >>> StaffFirstName, StaffFirstName
        
        ItemTable
        ProjectID(FK)(PK), ItemID(FK)(PK), Description, CheckInNotes, CheckOutNotes, DateOut, DateIn, PricePerDay, Days, ExtPrice, HistoricPricePerDay)

        ItemPriceTable
        ItemID(PK), Description, PricePerDay,

~Joe's Video Store: Video Information
    VideoID
        Title
    MovieTypes:
        TypeID
        TypeName
    TotalNumberOfCopies
        NumberOfCopiesAvalableForRental
    Format
    Cost
    RentalCharge
    MovieRating
        RatingCode
        RatingDescription
    CopyNumber
    AvailableForRental

    CopyNumber

    ~ONF: 
        VideoTable
        VideoID(PK), Title, TypeID, TypeName, TotalNumberOfCopy, NumberOfCopyAvailability, Format, Cost, RentalCharge, RatingCode, RatingDescription, 
        (CopyNumber, Availability)
    ~1NF: 
        VideoInformationTable
        VideoID(PK), Title, TypeID, TypeName, TotalNumberOfCopy, NumberOfCopyAvailability, Format, Cost, RentalCharge, RatingCode, RatingDescription, 

        VideoCopyTable 
        VideoID(FK)(PK), CopyNumber(PK), Availability
    ~2NF: 
        VideoInformationTable
        VideoID(PK), Title, TypeID, TypeName, TotalNumberOfCopy, NumberOfCopyAvailability, Format, Cost, RentalCharge, RatingCode, RatingDescription, 

        VideoCopyTable 
        VideoID(FK)(PK), CopyNumber(PK), Availability
    ~3NF: 
        VideoInformationTable
        VideoID(PK), Title, TypeID(FK), TotalNumberOfCopy, NumberOfCopyAvailability, Format(FK), Cost, RentalCharge, RatingCode(FK), RatingDescription, 
            TypeTable
            TypeID(PK), TypeName,
        
            RatingTable
            RatingCode(PK), RatingDescription
            
            FormatTable
            FormatID(PK), FormatDescription
    
        VideoCopyTable 
        VideoID(FK)(PK), CopyNumber(PK), Availability


~VIDEO RENTALS VIEW: Joe's Video Store: Video Rentals
TransactionID: 123
    CustomerID:
        Phone:
        Date: 
        Name >>> FirstName, LastName
        Address >>> Street, City, Province, Postal
    VideoID:
        CopyNumber
        Title
        ReturnDate
        RentalCharge >>> CurrentCharge, HistoricRentalCharge
    Subtotal:
    GST:
    Total:

    : 0NF: 
        TransactionTable
        TransactionID(PK), Subtotal, GST, Total, CustomerID, Phone, Date, Name, Address,
        (VideoID, CopyNumber, Title, ReturnDate, RentalCurrentRentalCharge, HistoricRentalCharge)
    : 1NF:
        TransactionTable
        TransactionID(PK), Subtotal, GST, Total, CustomerID, Phone, Date, FirstName, LastName, Street, City, Province, Postal,
        
        VideoTable
        TransactionID(FK)(PK), VideoID(PK), CopyNumber(PK), Title, ReturnDate, CurrentRentalCharge, HistoricRentalCharge
    : 2NF:
        TransactionTable
        TransactionID(PK), Subtotal, GST, Total, CustomerID, Phone, Date, FirstName, LastName, Street, City, Province, Postal,
        
        TransactionDetailTable
        TransactionID(FK)(PK), VideoID(FK)(PK), CopyNumber(PK), ReturnDate, HistoricRentalCharge

        VideoTable
        VideoID(PK), Title, CurrentRentalCXharge
    : 3NF:
        TransactionTable
        TransactionID(PK), Subtotal, GST, Total, CustomerID(FK)
            
            CustomerTable
            CustomerID(PK), Phone, Date, FirstName, LastName, Street, City, Province, Postal
        
        TransactionDetailTable
        TransactionID(FK)(PK), VideoID(FK)(PK), CopyNumber(PK), Title, ReturnDate, CurrentRentalCharge, HistoricRentalCharge)

        VideoTable
        VideoID(PK), Title, CurrentRentalCXharge

~ESP3: Inventory Control View "Inventory Control Sheet"
    ItemTable
    (PK)ItemNumber: M24
        ItemDescription: Bolts-24mm
        CurrentSalePrice: $0.29
        +QuantityOnHand
        +ReorderLvl
        
        ItemInventoryTable
        (FK)(PK)ItemNumber
        (FK)(PK)PONumber:       125, 131, 149
            Quantity:       1000, 2000, 2000
            Cost:           0.13, 0.13, 0.14

            PurchaseOrderTable
            (PK)PONumber 
            OrderDate:      July 1, 1998, August 2, 1998, September 5, 1998
            SupplierNumber: 7, 10, 7


: 0NF:
    ItemTable
    ItemNumber, ItemDescription, CurrentSalePrice, QuantityOnHand, ReorderLvl
    (OrderDate, SupplierNumber, PONumber, Quantity, Cost)
: 1NF:
    ItemTable
    ItemNumber(PK), ItemDescription, CurrentSalePrice, QuantityOnHand, ReorderLvl
    
    ItemInventoryTable
    ItemNumber(FK), PONumber(PK), OrderDate, SupplierNumber, Quantity, Cost
: 2NF:
    ItemTable
    ItemNumber(PK), ItemDescription, CurrentSalePrice, QuantityOnHand, ReorderLvl
    
    ItemInventoryTable
    ItemNumber(FK)(PK), PONumber(FK)(PK), Quantity, Cost

    PurchaseOrderTable
    PONumber(PK), OrderDate, SupplierNumber
: 3NF:
    ItemTable
    ItemNumber(PK), ItemDescription, CurrentSalePrice, QuantityOnHand, ReorderLvl
    
    ItemInventoryTable
    ItemNumber(FK)(PK), PONumber(FK)(PK), Quantity, Cost

    PurchaseOrderTable
    PONumber(PK), OrderDate, SupplierNumber

~ESP4: Purchase Orders
PurchaseOrderTable
PurchaseOrderNumber: #125
    Date: July 1, 1998
    Subtotal: 151.97
    GST: 10.64
    Total: 162.61

    PurchasedItemTable    
    ItemNumber: H23, H319, M24
        SuppliersItemNumber: S103, B11a, ISO4
        SuppliersItemDescription: Heater Fan Belt - 23*, Heater Fan Support Brackets, Bolds - 24mm
        Quantity: 1, 2, 1000
        Cost: 11.99, 4.99, 0.13
        Amount: 11.99, 9.,98, 130.00

SupplierTable
SupplierNumber: 7
    SuppliersName: Nuts and Bolts
    SuppliersAddress: 11123 - 114 Avenue
    City: Edmonton, AB, T6G 4X1
    Phone: 488-2312

: 0NF:
    PurchaseOrderNumber, Date, Subtotal, GST, Total, SupplierName, Address, City, Phone,
    (ItemNumber, SuppliersItemNumber, SuppliersDescription, Quantity, Cost, Amount)
: 1NF:
    PurchaseOrderTable
    PurchaseOrderNumber(PK), Date, Subtotal, GST, Total, SupplierNumber, SupplierNumber(PK)(FK), SupplierName, SupplierCity, SupplierProvince, SupplierPostalCode, Phone,
    PurchasedItemTable
    PurchaseOrderNumber(FK)(PK), ItemNumber(PK), SuppliersItemNumber, SuppliersItemDescription, Quantity, Cost, Amount
: 2NF: (No Change)
    PurchaseOrderTable
    PurchaseOrderNumber(PK), Date, Subtotal, GST, Total, SupplierNumber, SupplierNumber(PK)(FK), SupplierName, SupplierCity, SupplierProvince, SupplierPostalCode, Phone,
        PurchasedItemTable
        PurchaseOrderNumber(FK)(PK), ItemNumber(PK), SuppliersItemNumber, SuppliersItemDescription, Quantity, Cost, Amount
 : 3NF:
    PurchaseOrderTable
    PurchaseOrderNumber(PK), SupplierNumber(FK), Date, Subtotal, GST, Total
        PurchasedItemTable
        PurchaseOrderNumber(PK)(FK), ItemNumber(PK), SuppliersItemNumber, SuppliersItemDescription, Quantity, Cost, Amount
    SupplierTable
    SupplierNumber(PK), SupplierName, SupplierCity, SupplierProvince, SupplierPostalCode, Phone,

~ESP4: Purchase Orders Payments: ChequeRegister
SupplierNumber: 7, null, 15
SupplierName: Nuts & Bolts, Home Hardware
    ChequeTable
    ChequeNumber: 245, 246
        ChequeAmount: $823.18, $427.39
        PaymentDate: Jan 11/99, Jan 18/99
    PurchaseOrderNumber: 79, 81, 82
    PurchaseOrderDate: Dec 23/98, Dec 29/98, Dec... 

: 0NF:
    InitialTable
    ChequeNumber(PK), ChequeAmount, PaymentDate, SupplierNumber, SupplierName, 
    (PurchaseOrderNumber, PurchaseOrderDate)
: 1NF-2NF:
    ChequeTable
    ChequeNumber(PK), ChequeAmount, PaymentDate, SupplierNumner, SupplierName
        PurchaseOrderTable
        ChequeNumber(FK), PurchaseOrderNumber(PK), PurchaseOrderDate
: 3NF:
    ChequeTable
    ChequeNumber(PK), ChequeAmount, PaymentDate, SupplierNumner(FK)
        PurchaseOrderTable
        ChequeNumber(FK), PurchaseOrderNumber(PK), PurchaseOrderDate
    SupplierTable
    SupplierNumber(PK), SupplierName,

~ESP:
~Customer Detail View:
    : 0NF: INITIAL TABLE:
        CustomerDetails
        CustomerNumber(PK),
            Name
            Address
            City
            Province
            PostalCode
            HomePhone
    : 1NF: Composite >>> Atomic
        CustomerDetails
        CustomerNumber(PK),
            Name >>> LastName, FirstName
            Address
            City
            Province
            PostalCode
            HomePhone
    : 2NF:
        CustomerDetails
        CustomerNumber(PK),
            LastName, FirstName
            Address
            City
            Province
            PostalCode
            HomePhone
    : 3NF:
        CustomerDetails
        CustomerNumber(PK),
            LastName, FirstName
            Address
            City
            Province
            PostalCode
            HomePhone
    : ERD:
        CUSTOMER
        ---------------------
        |   CustomerNumber  |
        |-------------------| 
        |   FirstName       |
        |   LastName        |
        |   Address         |
        |   City            |
        |   Province        |
        |   PostalCode      |
        |   Phone           |
        ---------------------    

~Customer Orders View:
    : 0NF:
        Order
            CustomerName = Fred Smith
            Address = 123 SomeWhere St. Edmonton, Ab, T5H 2J9
            Phone = 436-7867
            CustomerNumber = 137
            Date = Jan 16, 2000
            OrderNumber(PK) = 219
            ItemNumber =
                H23
                H319
                M24
            Description = 
                Heater Fan Belt - 23 Degrees
                Heater Fan Belt Support Brackets
                Bolts - 24mm
            Quantity =
                1
                2
                8
            Price =
                11.99
                4.99
                0.29
            Amount =
                11.99
                9.98
                2.32
            Subtotal = 24.29
            GST = 1.70
            Total = 25.99

        Order
        OrderNumber(PK), CustomerNumber, CustomerName, Address, Phone, Date,
        (ItemNumber, Description, Quantity, CurrentPrice, SellingPrice, Amount), Subtotal, GST, Total

    : 1NF:
        Order
            OrderNumber(PK) = 219
                CustomerNumber = 137
                    CustomerName = Fred Smith
                        FirstName = Fred
                        LastName = Smith 
                    Address = 123 SomeWhere St. Edmonton, Ab, T5H 2J9
                        Street = 123 SomeWhere St.
                        City = Edmonton
                        Province = AB
                        Postal Code = T5H2J9
                    Phone = 436-7867
                Date = Jan 16, 2000
                Subtotal = 24.29
                GST = 1.70
                Total = 25.99
        OrderItem 
            OrderNumber(FK)(PK)
                ItemNumber(PK) =
                    H23
                    H319
                    M24
                    Description = 
                        Heater Fan Belt - 23 Degrees
                        Heater Fan Belt Support Brackets
                        Bolts - 24mm
                    Quantity =
                        1
                        2
                        8
                    CurrentPrice=
                    SellingPrice=
                        11.99
                        4.99
                        0.29
                    Amount =
                        11.99
                        9.98
                    2.32
        Order
        OrderNumber(PK), CustomerNumber, LastName, FirstName, Street, City, Province, PostalCode, Phone, Date, Subtotal, GST, Total

        OrderItem
        OrderNumber(FK)(PK), ItemNumber(PK), Description, Quantity, CurrentPrice, SellingPrice, Amount

    : 2NF:
        Order
            OrderNumber(PK) = 219
                CustomerNumber = 137
                    CustomerName = Fred Smith
                        FirstName = Fred
                        LastName = Smith 
                    Address = 123 SomeWhere St. Edmonton, Ab, T5H 2J9
                        Street = 123 SomeWhere St.
                        City = Edmonton
                        Province = AB
                        Postal Code = T5H2J9
                    Phone = 436-7867
                Date = Jan 16, 2000
                Subtotal = 24.29
                GST = 1.70
                Total = 25.99
        OrderItem 
            OrderNumber(FK)(PK)
                ItemNumber(FK)(PK) =
                    H23
                    H319
                    M24
                Quantity =
                    1
                    2
                    8        
                SellingPrice=
                    11.99
                    4.99
                    0.29
                Amount =
                    11.99
                    9.98
                    2.32        
        Item 
            ItemNumber(PK)
            Description = 
                Heater Fan Belt - 23 Degrees
                Heater Fan Belt Support Brackets
                Bolts - 24mm
            CurrentPrice=

        Order
        OrderNumber(PK), CustomerNumber, LastName, FirstName, Street, City, Province, PostalCode, Phone, Date, Subtotal, GST, Total

        OrderItem
        OrderNumber(FK)(PK), ItemNumber(FK)(PK), Quantity, SellingPrice, Amount

        Item
        ItemNumber(PK), Description, CurrentPrice

    : 3NF:
        Order
            OrderNumber(PK) = 219
                CustomerNumber(FK) = 137
                    CustomerName = Fred Smith
                        FirstName = Fred
                        LastName = Smith 
                    Address = 123 SomeWhere St. Edmonton, Ab, T5H 2J9
                        Street = 123 SomeWhere St.
                        City = Edmonton
                        Province = AB
                        Postal Code = T5H2J9
                    Phone = 436-7867
                Date = Jan 16, 2000
                Subtotal = 24.29
                GST = 1.70
                Total = 25.99
        Customer
            CustomerNumber(PK)
                FirstName
                LastName
            Address 
                Street
                City
                Province
                PostalCode
            Phone
        OrderItem 
            OrderNumber(FK)(PK)
                ItemNumber(FK)(PK) =
                    H23
                    H319
                    M24
                Quantity =
                    1
                    2
                    8        
                SellingPrice=
                    11.99
                    4.99
                    0.29
                Amount =
                    11.99
                    9.98
                    2.32        
        Item 
            ItemNumber(PK)
            Description = 
                Heater Fan Belt - 23 Degrees
                Heater Fan Belt Support Brackets
                Bolts - 24mm
            CurrentPrice=

        Order
        OrderNumber(PK), CustomerNumber(FK), Date, Subtotal, GST, Total

        Customer
        CustomerNumber(PK), FirstName, LastName, Address, City, Province, PostalCode, Phone

        OrderItem
        OrderNumber(FK)(PK), ItemNumber(FK)(PK), Quantity, SellingPrice, Amount

        Item
        ItemNumber(PK), Description, CurrentPrice

~ESP2: Customer Payments Against Orders
    : 0NF: PaymentLog
        CustomerName    = David Williams
        CustomerNumber  = 78
        OrderNumber     = 123
        OrderDate       = Jan 11/2029
        OrderTotal      = $145.18
        Date            =
                        Jan 11/99
                        Jan 18/99
        PaymentAmount   =
                        100.00
                        45.18
        PaymentNumber   =
                        1
                        2
        BalanceOwing    =
                        45.18
                        0.00
        PaymentType     =
                        Cheque
                        Cash
        DepositBranch#  =
                        118
                        118
    : 1-2-3NF: PaymentLog
        OrderTable
        OrderNumber(FK)(PK) = 123
            OrderDate           = Jan 11/2029
            OrderTotal          = $145.18
            CustomerNumber(FK)
            
            CustomerTable
            CustomerNumber(PK) = 78
                CustomerName
                    FirstName   = David
                    LastName    = Williams
        
            PaymentTable
            PaymentNumber(PK)=
                                1
                                2                
                    PaymentDate     =
                                    Jan 11/99
                                    Jan 18/99
                    PaymentAmount   =
                                    100.00
                                    45.18
                    BalanceOwing    =
                                    45.18
                                    0.00
                    PaymentType     =
                                    Cheque
                                    Cash
                    DepositBranch#  =
                                    118
                                    118
    Initial Table:
        OrderTable
        OrderNumber(PK), OrderDate, OrderTotal, CustomerName, CustomerNumber
        (PaymentDate, PaymentAmount, PaymentNumber, BalanceOwing, PaymentType, DepositBranchNumber)
    
    1-2NF Table:
        OrderTable
        OrderNumber(PK), OrderDate, OrderTotal, FirstName, LastName, CustomerNumber
        
        PaymentTable
        OrderNumber(PK)(FK), PaymentDate, PaymentAmount, PaymentNumber(PK), BalanceOwing, PaymentType, DepositBranchNumber

    3NF Table:
        OrderTable
        OrderNumber(FK)(PK), OrderDate, OrderTotal, CustomerName, CustomerNumber(FK), 

        CustomerTable
        CustomerNumber(PK) FistName, LastName

        PaymentTable
        OrderNumber(PK)(FK), PaymentNumber(PK), PaymentDate, PaymentAmount, BalanceOwing, PaymentType, DepositBranchNumber


###############################################################################################################################
: DATABASE ENGINE: The core set of programs in a DBMS that handles all database operations.
    : DATA DEFINITION LANGUAGE: Sets up the database structure for efficient storage.
        Use CREATE, ALTER, DROP commands.
    : SQL Queries: Extract insights and support decision-making.
        Use SELECT, WHERE, JOIN, and aggregate functions.
    : DATA MANIPULATION LANGUAGE: Keep datacase data updated and accurate.
        Use INSERT, UPDATE, DELETE statements.
    : STORED PROCEDURES: Improve performance and handle business logic efficiently.
        Use CREATE, PROCEDURE, parameters, transactions, and error handing.
    : TRIGGERS: Enforce rules and log/audit changes automatically.
        Use CREATE TRIGGER for specific events like INSERT, UPDATE, or DELETE.
